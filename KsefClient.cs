//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace Ksef.Client
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IKsefApiClient
    {
        /// <summary>
        /// Pobranie listy aktywnych sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę aktywnych sesji uwierzytelnienia.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationListResponse> SessionsGETAsync(string x_continuation_token, int? pageSize);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy aktywnych sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę aktywnych sesji uwierzytelnienia.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationListResponse> SessionsGETAsync(string x_continuation_token, int? pageSize, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Unieważnienie aktualnej sesji uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Unieważnia sesję powiązaną z tokenem użytym do wywołania tej operacji.
        /// <br/>
        /// <br/>Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można już za jego pomocą uzyskać kolejnych access tokenów.
        /// <br/>**Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `RefreshToken` lub `AccessToken`.
        /// </remarks>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CurrentAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unieważnienie aktualnej sesji uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Unieważnia sesję powiązaną z tokenem użytym do wywołania tej operacji.
        /// <br/>
        /// <br/>Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można już za jego pomocą uzyskać kolejnych access tokenów.
        /// <br/>**Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `RefreshToken` lub `AccessToken`.
        /// </remarks>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CurrentAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Unieważnienie sesji uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Unieważnia sesję o podanym numerze referencyjnym.
        /// <br/>
        /// <br/>Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można już za jego pomocą uzyskać kolejnych access tokenów.
        /// <br/>**Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji uwierzytelnienia.</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SessionsDELETEAsync(string referenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unieważnienie sesji uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Unieważnia sesję o podanym numerze referencyjnym.
        /// <br/>
        /// <br/>Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można już za jego pomocą uzyskać kolejnych access tokenów.
        /// <br/>**Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji uwierzytelnienia.</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SessionsDELETEAsync(string referenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie danych o limitach certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o limitach certyfikatów oraz informacje czy użytkownik może zawnioskować o certyfikat KSeF.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CertificateLimitsResponse> LimitsAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie danych o limitach certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o limitach certyfikatów oraz informacje czy użytkownik może zawnioskować o certyfikat KSeF.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CertificateLimitsResponse> LimitsAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie danych do wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Zwraca dane wymagane do przygotowania wniosku certyfikacyjnego PKCS#10.
        /// <br/>
        /// <br/>Dane te są zwracane na podstawie certyfikatu użytego w procesie uwierzytelnienia i identyfikują podmiot, który składa wniosek o certyfikat.
        /// <br/>
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobranie danych do wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#2-pobranie-danych-do-wniosku-certyfikacyjnego)
        /// <br/>&gt; - [Przygotowanie wniosku](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#3-przygotowanie-csr-certificate-signing-request)
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CertificateEnrollmentDataResponse> DataAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie danych do wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Zwraca dane wymagane do przygotowania wniosku certyfikacyjnego PKCS#10.
        /// <br/>
        /// <br/>Dane te są zwracane na podstawie certyfikatu użytego w procesie uwierzytelnienia i identyfikują podmiot, który składa wniosek o certyfikat.
        /// <br/>
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobranie danych do wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#2-pobranie-danych-do-wniosku-certyfikacyjnego)
        /// <br/>&gt; - [Przygotowanie wniosku](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#3-przygotowanie-csr-certificate-signing-request)
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CertificateEnrollmentDataResponse> DataAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Wysyłka wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Przyjmuje wniosek certyfikacyjny i rozpoczyna jego przetwarzanie.
        /// <br/>
        /// <br/>Dozwolone typy kluczy prywatnych używanych do podpisu wniosku (CSR):
        /// <br/>- RSA (OID: 1.2.840.113549.1.1.1), długość klucza co najmniej 2048 bitów,
        /// <br/>- EC (klucze oparte na krzywych eliptycznych, OID: 1.2.840.10045.2.1), długość klucza co najmniej 256 bitów.
        /// <br/>
        /// <br/>Rekomendowane jest wykorzystywanie kluczy EC.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Wysłanie wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#4-wys%C5%82anie-wniosku-certyfikacyjnego)
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EnrollCertificateResponse> EnrollmentsPOSTAsync(EnrollCertificateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Wysyłka wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Przyjmuje wniosek certyfikacyjny i rozpoczyna jego przetwarzanie.
        /// <br/>
        /// <br/>Dozwolone typy kluczy prywatnych używanych do podpisu wniosku (CSR):
        /// <br/>- RSA (OID: 1.2.840.113549.1.1.1), długość klucza co najmniej 2048 bitów,
        /// <br/>- EC (klucze oparte na krzywych eliptycznych, OID: 1.2.840.10045.2.1), długość klucza co najmniej 256 bitów.
        /// <br/>
        /// <br/>Rekomendowane jest wykorzystywanie kluczy EC.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Wysłanie wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#4-wys%C5%82anie-wniosku-certyfikacyjnego)
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EnrollCertificateResponse> EnrollmentsPOSTAsync(EnrollCertificateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie statusu przetwarzania wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o statusie wniosku certyfikacyjnego.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny wniosku certyfikacyjnego</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CertificateEnrollmentStatusResponse> EnrollmentsGETAsync(string referenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu przetwarzania wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o statusie wniosku certyfikacyjnego.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny wniosku certyfikacyjnego</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CertificateEnrollmentStatusResponse> EnrollmentsGETAsync(string referenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie certyfikatu lub listy certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca certyfikaty o podanych numerach seryjnych w formacie DER zakodowanym w Base64.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RetrieveCertificatesResponse> RetrieveAsync(RetrieveCertificatesRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie certyfikatu lub listy certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca certyfikaty o podanych numerach seryjnych w formacie DER zakodowanym w Base64.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RetrieveCertificatesResponse> RetrieveAsync(RetrieveCertificatesRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Unieważnienie certyfikatu
        /// </summary>
        /// <remarks>
        /// Unieważnia certyfikat o podanym numerze seryjnym.
        /// </remarks>
        /// <param name="certificateSerialNumber">Numer seryjny certyfikatu (w formacie szesnastkowym).</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RevokeAsync(string certificateSerialNumber, RevokeCertificateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unieważnienie certyfikatu
        /// </summary>
        /// <remarks>
        /// Unieważnia certyfikat o podanym numerze seryjnym.
        /// </remarks>
        /// <param name="certificateSerialNumber">Numer seryjny certyfikatu (w formacie szesnastkowym).</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RevokeAsync(string certificateSerialNumber, RevokeCertificateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie listy metadanych certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca listę certyfikatów spełniających podane kryteria wyszukiwania.
        /// <br/>W przypadku braku podania kryteriów wyszukiwania zwrócona zostanie nieprzefiltrowana lista.
        /// </remarks>
        /// <param name="pageSize">Rozmiar strony wyników</param>
        /// <param name="pageOffset">Numer strony wyników</param>
        /// <param name="body">Kryteria filtrowania</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryCertificatesResponse> QueryAsync(int? pageSize, int? pageOffset, QueryCertificatesRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy metadanych certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca listę certyfikatów spełniających podane kryteria wyszukiwania.
        /// <br/>W przypadku braku podania kryteriów wyszukiwania zwrócona zostanie nieprzefiltrowana lista.
        /// </remarks>
        /// <param name="pageSize">Rozmiar strony wyników</param>
        /// <param name="pageOffset">Numer strony wyników</param>
        /// <param name="body">Kryteria filtrowania</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryCertificatesResponse> QueryAsync(int? pageSize, int? pageOffset, QueryCertificatesRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o kluczach publicznych używanych do szyfrowania danych przesyłanych do systemu KSeF.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<PublicKeyCertificate>> PublicKeyCertificatesAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o kluczach publicznych używanych do szyfrowania danych przesyłanych do systemu KSeF.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<PublicKeyCertificate>> PublicKeyCertificatesAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Utworzenie podmiotu
        /// </summary>
        /// <remarks>
        /// Tworzenie nowego podmiotu testowego. W przypadku grupy VAT i JST istnieje możliwość stworzenia jednostek podrzędnych. W wyniku takiego działania w systemie powstanie powiązanie między tymi podmiotami.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SubjectAsync(SubjectCreateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Utworzenie podmiotu
        /// </summary>
        /// <remarks>
        /// Tworzenie nowego podmiotu testowego. W przypadku grupy VAT i JST istnieje możliwość stworzenia jednostek podrzędnych. W wyniku takiego działania w systemie powstanie powiązanie między tymi podmiotami.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SubjectAsync(SubjectCreateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Usunięcie podmiotu
        /// </summary>
        /// <remarks>
        /// Usuwanie podmiotu testowego. W przypadku grupy VAT i JST usunięte zostaną również jednostki podrzędne.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveAsync(SubjectRemoveRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Usunięcie podmiotu
        /// </summary>
        /// <remarks>
        /// Usuwanie podmiotu testowego. W przypadku grupy VAT i JST usunięte zostaną również jednostki podrzędne.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveAsync(SubjectRemoveRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Utworzenie osoby fizycznej
        /// </summary>
        /// <remarks>
        /// Tworzenie nowej osoby fizycznej, której system nadaje uprawnienia właścicielskie. Można również określić, czy osoba ta jest komornikiem – wówczas otrzyma odpowiednie uprawnienie egzekucyjne.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PersonAsync(PersonCreateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Utworzenie osoby fizycznej
        /// </summary>
        /// <remarks>
        /// Tworzenie nowej osoby fizycznej, której system nadaje uprawnienia właścicielskie. Można również określić, czy osoba ta jest komornikiem – wówczas otrzyma odpowiednie uprawnienie egzekucyjne.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PersonAsync(PersonCreateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Usunięcie osoby fizycznej
        /// </summary>
        /// <remarks>
        /// Usuwanie testowej osoby fizycznej. System automatycznie odbierze jej wszystkie uprawnienia.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Remove2Async(PersonRemoveRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Usunięcie osoby fizycznej
        /// </summary>
        /// <remarks>
        /// Usuwanie testowej osoby fizycznej. System automatycznie odbierze jej wszystkie uprawnienia.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Remove2Async(PersonRemoveRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Nadanie uprawnień testowemu podmiotowi/osobie fizycznej
        /// </summary>
        /// <remarks>
        /// Nadawanie uprawnień testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PermissionsAsync(TestDataPermissionsGrantRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień testowemu podmiotowi/osobie fizycznej
        /// </summary>
        /// <remarks>
        /// Nadawanie uprawnień testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PermissionsAsync(TestDataPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Odebranie uprawnień testowemu podmiotowi/osobie fizycznej
        /// </summary>
        /// <remarks>
        /// Odbieranie uprawnień nadanych testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Revoke2Async(TestDataPermissionsRevokeRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Odebranie uprawnień testowemu podmiotowi/osobie fizycznej
        /// </summary>
        /// <remarks>
        /// Odbieranie uprawnień nadanych testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Revoke2Async(TestDataPermissionsRevokeRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Umożliwienie wysyłania faktur z załącznikiem
        /// </summary>
        /// <remarks>
        /// Dodaje możliwość wysyłania faktur z załącznikiem przez wskazany podmiot
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AttachmentAsync(AttachmentPermissionGrantRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Umożliwienie wysyłania faktur z załącznikiem
        /// </summary>
        /// <remarks>
        /// Dodaje możliwość wysyłania faktur z załącznikiem przez wskazany podmiot
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AttachmentAsync(AttachmentPermissionGrantRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Odebranie możliwości wysyłania faktur z załącznikiem
        /// </summary>
        /// <remarks>
        /// Odbiera możliwość wysyłania faktur z załącznikiem przez wskazany podmiot
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Revoke3Async(AttachmentPermissionRevokeRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Odebranie możliwości wysyłania faktur z załącznikiem
        /// </summary>
        /// <remarks>
        /// Odbiera możliwość wysyłania faktur z załącznikiem przez wskazany podmiot
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Revoke3Async(AttachmentPermissionRevokeRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Nadanie osobom fizycznym uprawnień do pracy w KSeF
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania osobom fizycznym uprawnień do pracy w KSeF.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadawanie-uprawnie%C5%84-osobom-fizycznym-do-pracy-w-ksef)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOSTAsync(PersonPermissionsGrantRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie osobom fizycznym uprawnień do pracy w KSeF
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania osobom fizycznym uprawnień do pracy w KSeF.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadawanie-uprawnie%C5%84-osobom-fizycznym-do-pracy-w-ksef)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOSTAsync(PersonPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Nadanie podmiotom uprawnień do obsługi faktur
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania podmiotom uprawnień do obsługi faktur.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-podmiotom-uprawnie%C5%84-do-obs%C5%82ugi-faktur)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST2Async(EntityPermissionsGrantRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie podmiotom uprawnień do obsługi faktur
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania podmiotom uprawnień do obsługi faktur.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-podmiotom-uprawnie%C5%84-do-obs%C5%82ugi-faktur)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST2Async(EntityPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Nadanie uprawnień podmiotowych
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień podmiotowych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-podmiotowych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST3Async(EntityAuthorizationPermissionsGrantRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień podmiotowych
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień podmiotowych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-podmiotowych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST3Async(EntityAuthorizationPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Nadanie uprawnień w sposób pośredni
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień w sposób pośredni.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-w-spos%C3%B3b-po%C5%9Bredni)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST4Async(IndirectPermissionsGrantRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień w sposób pośredni
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień w sposób pośredni.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-w-spos%C3%B3b-po%C5%9Bredni)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST4Async(IndirectPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Nadanie uprawnień administratora podmiotu podrzędnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień administratora podmiotu podrzędnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-administratora-podmiotu-podrz%C4%99dnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `SubunitManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST5Async(SubunitPermissionsGrantRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień administratora podmiotu podrzędnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień administratora podmiotu podrzędnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-administratora-podmiotu-podrz%C4%99dnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `SubunitManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST5Async(SubunitPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Nadanie uprawnień administratora podmiotu unijnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień administratora podmiotu unijnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-administratora-podmiotu-unijnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST6Async(EuEntityAdministrationPermissionsGrantRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień administratora podmiotu unijnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień administratora podmiotu unijnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-administratora-podmiotu-unijnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST6Async(EuEntityAdministrationPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Nadanie uprawnień reprezentanta podmiotu unijnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień reprezentanta podmiotu unijnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-reprezentanta-podmiotu-unijnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `VatUeManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST7Async(EuEntityPermissionsGrantRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień reprezentanta podmiotu unijnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień reprezentanta podmiotu unijnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-reprezentanta-podmiotu-unijnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `VatUeManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST7Async(EuEntityPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Odebranie uprawnień
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operacje odbierania uprawnienia o podanym identyfikatorze.
        /// <br/>
        /// <br/>Ta metoda służy do odbierania uprawnień takich jak:
        /// <br/>- nadanych nadanych osobom fizycznym lub podmiotom do pracy w KSeF
        /// <br/>- nadanych podmiotom do obsługi faktur
        /// <br/>- nadanych w sposób pośredni
        /// <br/>- administratorów jednostek i podmiotów podrzędnych
        /// <br/>- administratorów podmiotów unijnych uprawnionych do samofakturowania
        /// <br/>- reprezentantów podmiotów unijnych
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#odebranie-uprawnie%C5%84)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="permissionId">Id uprawnienia.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsDELETEAsync(string permissionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Odebranie uprawnień
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operacje odbierania uprawnienia o podanym identyfikatorze.
        /// <br/>
        /// <br/>Ta metoda służy do odbierania uprawnień takich jak:
        /// <br/>- nadanych nadanych osobom fizycznym lub podmiotom do pracy w KSeF
        /// <br/>- nadanych podmiotom do obsługi faktur
        /// <br/>- nadanych w sposób pośredni
        /// <br/>- administratorów jednostek i podmiotów podrzędnych
        /// <br/>- administratorów podmiotów unijnych uprawnionych do samofakturowania
        /// <br/>- reprezentantów podmiotów unijnych
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#odebranie-uprawnie%C5%84)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="permissionId">Id uprawnienia.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsDELETEAsync(string permissionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Odebranie uprawnień podmiotowych
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operacje odbierania uprawnienia o podanym identyfikatorze.
        /// <br/>Ta metoda służy do odbierania uprawnień podmiotowych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#odebranie-uprawnie%C5%84-podmiotowych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="permissionId">Id uprawnienia.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsDELETE2Async(string permissionId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Odebranie uprawnień podmiotowych
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operacje odbierania uprawnienia o podanym identyfikatorze.
        /// <br/>Ta metoda służy do odbierania uprawnień podmiotowych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#odebranie-uprawnie%C5%84-podmiotowych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="permissionId">Id uprawnienia.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsDELETE2Async(string permissionId, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie statusu operacji
        /// </summary>
        /// <remarks>
        /// Zwraca status operacji asynchronicznej związanej z nadaniem lub odebraniem uprawnień.
        /// </remarks>
        /// <param name="operationReferenceNumber">Numer referencyjny operacji</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationStatusResponse> OperationsAsync(string operationReferenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu operacji
        /// </summary>
        /// <remarks>
        /// Zwraca status operacji asynchronicznej związanej z nadaniem lub odebraniem uprawnień.
        /// </remarks>
        /// <param name="operationReferenceNumber">Numer referencyjny operacji</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PermissionsOperationStatusResponse> OperationsAsync(string operationReferenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie faktury po numerze KSeF
        /// </summary>
        /// <remarks>
        /// Zwraca fakturę o podanym numerze KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="ksefNumber">Numer KSeF faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> KsefAsync(string ksefNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie faktury po numerze KSeF
        /// </summary>
        /// <remarks>
        /// Zwraca fakturę o podanym numerze KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="ksefNumber">Numer KSeF faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> KsefAsync(string ksefNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie listy metadanych faktur
        /// </summary>
        /// <remarks>
        /// Zwraca listę metadanych faktur spełniające podane kryteria wyszukiwania.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="pageOffset">Indeks pierwszej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <param name="body">Zestaw filtrów dla wyszukiwania metadanych.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryInvoicesMetadataReponse> MetadataAsync(int? pageOffset, int? pageSize, InvoicesMetadataQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy metadanych faktur
        /// </summary>
        /// <remarks>
        /// Zwraca listę metadanych faktur spełniające podane kryteria wyszukiwania.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="pageOffset">Indeks pierwszej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <param name="body">Zestaw filtrów dla wyszukiwania metadanych.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryInvoicesMetadataReponse> MetadataAsync(int? pageOffset, int? pageSize, InvoicesMetadataQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// [mock] Eksport paczki faktur
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczny proces wyszukiwania faktur w systemie KSeF na podstawie przekazanych filtrów oraz przygotowania ich w formie zaszyfrowanej paczki.
        /// <br/>Wymagane jest przekazanie informacji o szyfrowaniu w polu `Encryption`, które służą do zabezpieczenia przygotowanej paczki z fakturami.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ExportInvoicesResponse> ExportsPOSTAsync(InvoicesExportRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// [mock] Eksport paczki faktur
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczny proces wyszukiwania faktur w systemie KSeF na podstawie przekazanych filtrów oraz przygotowania ich w formie zaszyfrowanej paczki.
        /// <br/>Wymagane jest przekazanie informacji o szyfrowaniu w polu `Encryption`, które służą do zabezpieczenia przygotowanej paczki z fakturami.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ExportInvoicesResponse> ExportsPOSTAsync(InvoicesExportRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// [mock] Pobranie statusu eksportu paczki faktur
        /// </summary>
        /// <remarks>
        /// Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="operationReferenceNumber">Numer referencyjny operacji.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InvoicesExportStatusResponse> ExportsGETAsync(string operationReferenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// [mock] Pobranie statusu eksportu paczki faktur
        /// </summary>
        /// <remarks>
        /// Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="operationReferenceNumber">Numer referencyjny operacji.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InvoicesExportStatusResponse> ExportsGETAsync(string operationReferenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie listy sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę sesji spełniających podane kryteria wyszukiwania.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `Introspection`.
        /// </remarks>
        /// <param name="pageSize">Rozmiar strony.</param>
        /// <param name="sessionType">Typ sesji.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Online | Wysyłka interaktywna (pojedyncze faktury). |
        /// <br/>| Batch | Wysyłka wsadowa (paczka faktur). |</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="dateCreatedFrom">Data utworzenia sesji (od).</param>
        /// <param name="dateCreatedTo">Data utworzenia sesji (do).</param>
        /// <param name="dateClosedFrom">Data zamknięcia sesji (od).</param>
        /// <param name="dateClosedTo">Data zamknięcia sesji (do).</param>
        /// <param name="dateModifiedFrom">Data ostatniej aktywności (wysyłka faktury lub zmiana statusu) w ramach sesji (od).</param>
        /// <param name="dateModifiedTo">Data ostatniej aktywności (wysyłka faktury lub zmiana statusu) w ramach sesji (do).</param>
        /// <param name="statuses">Statusy sesji.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| InProgress | Sesja aktywna. |
        /// <br/>| Succeeded | Sesja przetworzona poprawnie.            W trakcie przetwarzania sesji nie wystąpiły żadne błędy, ale część faktur nadal mogła zostać odrzucona. |
        /// <br/>| Failed | Sesja nie przetworzona z powodu błędów.            Na etapie rozpoczynania lub kończenia sesji wystąpiły błędy, które nie pozwoliły na jej poprawne przetworzenie. |
        /// <br/>| Cancelled | Sesja anulowania.            Został przekroczony czas na wysyłkę w sesji wsadowej, lub nie przesłano żadnych faktur w sesji interaktywnej. |</param>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SessionsQueryResponse> SessionsGET2Async(int? pageSize, SessionType sessionType, string referenceNumber, System.DateTimeOffset? dateCreatedFrom, System.DateTimeOffset? dateCreatedTo, System.DateTimeOffset? dateClosedFrom, System.DateTimeOffset? dateClosedTo, System.DateTimeOffset? dateModifiedFrom, System.DateTimeOffset? dateModifiedTo, System.Collections.Generic.IEnumerable<CommonSessionStatus> statuses, string x_continuation_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę sesji spełniających podane kryteria wyszukiwania.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `Introspection`.
        /// </remarks>
        /// <param name="pageSize">Rozmiar strony.</param>
        /// <param name="sessionType">Typ sesji.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Online | Wysyłka interaktywna (pojedyncze faktury). |
        /// <br/>| Batch | Wysyłka wsadowa (paczka faktur). |</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="dateCreatedFrom">Data utworzenia sesji (od).</param>
        /// <param name="dateCreatedTo">Data utworzenia sesji (do).</param>
        /// <param name="dateClosedFrom">Data zamknięcia sesji (od).</param>
        /// <param name="dateClosedTo">Data zamknięcia sesji (do).</param>
        /// <param name="dateModifiedFrom">Data ostatniej aktywności (wysyłka faktury lub zmiana statusu) w ramach sesji (od).</param>
        /// <param name="dateModifiedTo">Data ostatniej aktywności (wysyłka faktury lub zmiana statusu) w ramach sesji (do).</param>
        /// <param name="statuses">Statusy sesji.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| InProgress | Sesja aktywna. |
        /// <br/>| Succeeded | Sesja przetworzona poprawnie.            W trakcie przetwarzania sesji nie wystąpiły żadne błędy, ale część faktur nadal mogła zostać odrzucona. |
        /// <br/>| Failed | Sesja nie przetworzona z powodu błędów.            Na etapie rozpoczynania lub kończenia sesji wystąpiły błędy, które nie pozwoliły na jej poprawne przetworzenie. |
        /// <br/>| Cancelled | Sesja anulowania.            Został przekroczony czas na wysyłkę w sesji wsadowej, lub nie przesłano żadnych faktur w sesji interaktywnej. |</param>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SessionsQueryResponse> SessionsGET2Async(int? pageSize, SessionType sessionType, string referenceNumber, System.DateTimeOffset? dateCreatedFrom, System.DateTimeOffset? dateCreatedTo, System.DateTimeOffset? dateClosedFrom, System.DateTimeOffset? dateClosedTo, System.DateTimeOffset? dateModifiedFrom, System.DateTimeOffset? dateModifiedTo, System.Collections.Generic.IEnumerable<CommonSessionStatus> statuses, string x_continuation_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie statusu sesji
        /// </summary>
        /// <remarks>
        /// Sprawdza bieżący status sesji o podanym numerze referencyjnym.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SessionStatusResponse> SessionsGET3Async(string referenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu sesji
        /// </summary>
        /// <remarks>
        /// Sprawdza bieżący status sesji o podanym numerze referencyjnym.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SessionStatusResponse> SessionsGET3Async(string referenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie faktur sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę faktur przesłanych w sesji wraz z ich statusami, oraz informacje na temat ilości poprawnie i niepoprawnie przetworzonych faktur.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SessionInvoicesResponse> InvoicesGETAsync(string x_continuation_token, string referenceNumber, int? pageSize);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie faktur sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę faktur przesłanych w sesji wraz z ich statusami, oraz informacje na temat ilości poprawnie i niepoprawnie przetworzonych faktur.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SessionInvoicesResponse> InvoicesGETAsync(string x_continuation_token, string referenceNumber, int? pageSize, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie statusu faktury z sesji
        /// </summary>
        /// <remarks>
        /// Zwraca fakturę przesłaną w sesji wraz ze statusem.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="invoiceReferenceNumber">Numer referencyjny faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SessionInvoiceStatusResponse> InvoicesGET2Async(string referenceNumber, string invoiceReferenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu faktury z sesji
        /// </summary>
        /// <remarks>
        /// Zwraca fakturę przesłaną w sesji wraz ze statusem.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="invoiceReferenceNumber">Numer referencyjny faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SessionInvoiceStatusResponse> InvoicesGET2Async(string referenceNumber, string invoiceReferenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie niepoprawnie przetworzonych faktur sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę niepoprawnie przetworzonych faktur przesłanych w sesji wraz z ich statusami.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SessionInvoicesResponse> FailedAsync(string x_continuation_token, string referenceNumber, int? pageSize);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie niepoprawnie przetworzonych faktur sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę niepoprawnie przetworzonych faktur przesłanych w sesji wraz z ich statusami.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SessionInvoicesResponse> FailedAsync(string x_continuation_token, string referenceNumber, int? pageSize, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie UPO faktury z sesji na podstawie numeru KSeF
        /// </summary>
        /// <remarks>
        /// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="ksefNumber">Numer KSeF faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> UpoAsync(string referenceNumber, string ksefNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie UPO faktury z sesji na podstawie numeru KSeF
        /// </summary>
        /// <remarks>
        /// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="ksefNumber">Numer KSeF faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> UpoAsync(string referenceNumber, string ksefNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie UPO faktury z sesji na podstawie numeru referencyjnego faktury
        /// </summary>
        /// <remarks>
        /// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="invoiceReferenceNumber">Numer referencyjny faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> Upo2Async(string referenceNumber, string invoiceReferenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie UPO faktury z sesji na podstawie numeru referencyjnego faktury
        /// </summary>
        /// <remarks>
        /// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="invoiceReferenceNumber">Numer referencyjny faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> Upo2Async(string referenceNumber, string invoiceReferenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie UPO dla sesji
        /// </summary>
        /// <remarks>
        /// Zwraca XML zawierający zbiorcze UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="upoReferenceNumber">Numer referencyjny UPO.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> Upo3Async(string referenceNumber, string upoReferenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie UPO dla sesji
        /// </summary>
        /// <remarks>
        /// Zwraca XML zawierający zbiorcze UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="upoReferenceNumber">Numer referencyjny UPO.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> Upo3Async(string referenceNumber, string upoReferenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Wygenerowanie nowego tokena
        /// </summary>
        /// <remarks>
        /// Zwraca token, który może być użyty do uwierzytelniania się w KSeF.
        /// <br/>
        /// <br/>Token jest zwracany tylko raz. Zaczyna być aktywny w momencie gdy jego status zmieni się na `Active`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenerateTokenResponse> TokensPOSTAsync(GenerateTokenRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Wygenerowanie nowego tokena
        /// </summary>
        /// <remarks>
        /// Zwraca token, który może być użyty do uwierzytelniania się w KSeF.
        /// <br/>
        /// <br/>Token jest zwracany tylko raz. Zaczyna być aktywny w momencie gdy jego status zmieni się na `Active`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenerateTokenResponse> TokensPOSTAsync(GenerateTokenRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie listy wygenerowanych tokenów
        /// </summary>
        /// <param name="status">Status tokenów do zwrócenia. W przypadku braku parametru zwracane są wszystkie tokeny. Parametr można przekazać wielokrotnie.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Pending | Token został utworzony ale jest jeszcze w trakcie aktywacji i nadawania uprawnień. Nie może być jeszcze wykorzystywany do uwierzytelniania. |
        /// <br/>| Active | Token jest aktywny i może być wykorzystywany do uwierzytelniania. |
        /// <br/>| Revoking | Token jest w trakcie unieważniania. Nie może już być wykorzystywany do uwierzytelniania. |
        /// <br/>| Revoked | Token został unieważniony i nie może być wykorzystywany do uwierzytelniania. |
        /// <br/>| Failed | Nie udało się aktywować tokena. Należy wygenerować nowy token, obecny nie może być wykorzystywany do uwierzytelniania. |</param>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryTokensResponse> TokensGETAsync(System.Collections.Generic.IEnumerable<AuthenticationTokenStatus> status, string x_continuation_token, int? pageSize);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy wygenerowanych tokenów
        /// </summary>
        /// <param name="status">Status tokenów do zwrócenia. W przypadku braku parametru zwracane są wszystkie tokeny. Parametr można przekazać wielokrotnie.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Pending | Token został utworzony ale jest jeszcze w trakcie aktywacji i nadawania uprawnień. Nie może być jeszcze wykorzystywany do uwierzytelniania. |
        /// <br/>| Active | Token jest aktywny i może być wykorzystywany do uwierzytelniania. |
        /// <br/>| Revoking | Token jest w trakcie unieważniania. Nie może już być wykorzystywany do uwierzytelniania. |
        /// <br/>| Revoked | Token został unieważniony i nie może być wykorzystywany do uwierzytelniania. |
        /// <br/>| Failed | Nie udało się aktywować tokena. Należy wygenerować nowy token, obecny nie może być wykorzystywany do uwierzytelniania. |</param>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryTokensResponse> TokensGETAsync(System.Collections.Generic.IEnumerable<AuthenticationTokenStatus> status, string x_continuation_token, int? pageSize, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie statusu tokena
        /// </summary>
        /// <param name="referenceNumber">Numer referencyjny tokena.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationToken> TokensGET2Async(string referenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu tokena
        /// </summary>
        /// <param name="referenceNumber">Numer referencyjny tokena.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationToken> TokensGET2Async(string referenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Unieważnienie tokena
        /// </summary>
        /// <remarks>
        /// Unieważniony token nie pozwoli już na uwierzytelnienie się za jego pomocą. Unieważnienie nie może zostać cofnięte.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny tokena do unieważeniania.</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TokensDELETEAsync(string referenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unieważnienie tokena
        /// </summary>
        /// <remarks>
        /// Unieważniony token nie pozwoli już na uwierzytelnienie się za jego pomocą. Unieważnienie nie może zostać cofnięte.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny tokena do unieważeniania.</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task TokensDELETEAsync(string referenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Inicjalizacja uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Generuje unikalny challenge wymagany w kolejnym kroku operacji uwierzytelnienia.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationChallengeResponse> ChallengeAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inicjalizacja uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Generuje unikalny challenge wymagany w kolejnym kroku operacji uwierzytelnienia.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationChallengeResponse> ChallengeAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Uwierzytelnienie z wykorzystaniem podpisu XAdES
        /// </summary>
        /// <remarks>
        /// Rozpoczyna operację uwierzytelniania za pomocą dokumentu XML podpisanego podpisem elektronicznym XAdES.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Przygotowanie dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.md#1-przygotowanie-dokumentu-xml-authtokenrequest)
        /// <br/>&gt; - [Podpis dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.md#2-podpisanie-dokumentu-xades)
        /// <br/>&gt; - [Schemat XSD](/docs/v2/schemas/authv2.xsd)
        /// </remarks>
        /// <param name="verifyCertificateChain">Wymuszenie weryfikacji zaufania łańcucha certyfikatu wraz ze sprawdzeniem statusu certyfikatu (OCSP/CRL) na środowiskach które umożliwiają wykorzystanie samodzielnie wygenerowanych certyfikatów.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationInitResponse> XadesSignatureAsync(bool? verifyCertificateChain, string body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Uwierzytelnienie z wykorzystaniem podpisu XAdES
        /// </summary>
        /// <remarks>
        /// Rozpoczyna operację uwierzytelniania za pomocą dokumentu XML podpisanego podpisem elektronicznym XAdES.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Przygotowanie dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.md#1-przygotowanie-dokumentu-xml-authtokenrequest)
        /// <br/>&gt; - [Podpis dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.md#2-podpisanie-dokumentu-xades)
        /// <br/>&gt; - [Schemat XSD](/docs/v2/schemas/authv2.xsd)
        /// </remarks>
        /// <param name="verifyCertificateChain">Wymuszenie weryfikacji zaufania łańcucha certyfikatu wraz ze sprawdzeniem statusu certyfikatu (OCSP/CRL) na środowiskach które umożliwiają wykorzystanie samodzielnie wygenerowanych certyfikatów.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationInitResponse> XadesSignatureAsync(bool? verifyCertificateChain, string body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Uwierzytelnienie z wykorzystaniem tokena KSeF
        /// </summary>
        /// <remarks>
        /// Rozpoczyna operację uwierzytelniania z wykorzystaniem wcześniej wygenerowanego tokena KSeF.
        /// <br/>
        /// <br/>Token KSeF wraz z timestampem ze wcześniej wygenerowanego challenge'a (w formacie ```token|timestamp```) powinien zostać zaszyfrowany dedykowanym do tego celu kluczem publicznym.
        /// <br/>- Timestamp powinien zostać przekazany jako **liczba milisekund od 1 stycznia 1970 roku (Unix timestamp)**.
        /// <br/>- Algorytm szyfrowania: **RSA-OAEP (z użyciem SHA-256 jako funkcji skrótu)**.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationInitResponse> KsefTokenAsync(InitTokenAuthenticationRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Uwierzytelnienie z wykorzystaniem tokena KSeF
        /// </summary>
        /// <remarks>
        /// Rozpoczyna operację uwierzytelniania z wykorzystaniem wcześniej wygenerowanego tokena KSeF.
        /// <br/>
        /// <br/>Token KSeF wraz z timestampem ze wcześniej wygenerowanego challenge'a (w formacie ```token|timestamp```) powinien zostać zaszyfrowany dedykowanym do tego celu kluczem publicznym.
        /// <br/>- Timestamp powinien zostać przekazany jako **liczba milisekund od 1 stycznia 1970 roku (Unix timestamp)**.
        /// <br/>- Algorytm szyfrowania: **RSA-OAEP (z użyciem SHA-256 jako funkcji skrótu)**.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationInitResponse> KsefTokenAsync(InitTokenAuthenticationRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie statusu uwierzytelniania
        /// </summary>
        /// <remarks>
        /// Sprawdza bieżący status operacji uwierzytelniania dla podanego tokena.
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji uwierzytelniania.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny tokena otrzymanego przy inicjalizacji operacji uwierzytelniania.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationOperationStatusResponse> AuthAsync(string referenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu uwierzytelniania
        /// </summary>
        /// <remarks>
        /// Sprawdza bieżący status operacji uwierzytelniania dla podanego tokena.
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji uwierzytelniania.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny tokena otrzymanego przy inicjalizacji operacji uwierzytelniania.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationOperationStatusResponse> AuthAsync(string referenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie tokenów dostępowych
        /// </summary>
        /// <remarks>
        /// Pobiera parę tokenów (access token i refresh token) wygenerowanych w ramach pozytywnie zakończonego procesu uwierzytelniania.
        /// <br/>**Tokeny można pobrać tylko raz.**
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji uwierzytelniania.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationTokensResponse> RedeemAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie tokenów dostępowych
        /// </summary>
        /// <remarks>
        /// Pobiera parę tokenów (access token i refresh token) wygenerowanych w ramach pozytywnie zakończonego procesu uwierzytelniania.
        /// <br/>**Tokeny można pobrać tylko raz.**
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji uwierzytelniania.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationTokensResponse> RedeemAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Odświeżenie tokena dostępowego
        /// </summary>
        /// <remarks>
        /// Generuje nowy token dostępu na podstawie ważnego refresh tokena.
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `RefreshToken`.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationTokenRefreshResponse> RefreshAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Odświeżenie tokena dostępowego
        /// </summary>
        /// <remarks>
        /// Generuje nowy token dostępu na podstawie ważnego refresh tokena.
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `RefreshToken`.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationTokenRefreshResponse> RefreshAsync(System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Otwarcie sesji interaktywnej
        /// </summary>
        /// <remarks>
        /// Otwiera sesję do wysyłki pojedynczych faktur. Należy przekazać schemat wysyłanych faktur oraz informacje o kluczu używanym do szyfrowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Otwarcie sesji interaktywnej](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#1-otwarcie-sesji)
        /// <br/>&gt; - [Klucz publiczny Ministersta Finansów](/public-keys/publicKey.pem)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OpenOnlineSessionResponse> OnlineSession_openAsync(OpenOnlineSessionRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Otwarcie sesji interaktywnej
        /// </summary>
        /// <remarks>
        /// Otwiera sesję do wysyłki pojedynczych faktur. Należy przekazać schemat wysyłanych faktur oraz informacje o kluczu używanym do szyfrowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Otwarcie sesji interaktywnej](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#1-otwarcie-sesji)
        /// <br/>&gt; - [Klucz publiczny Ministersta Finansów](/public-keys/publicKey.pem)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OpenOnlineSessionResponse> OnlineSession_openAsync(OpenOnlineSessionRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Wysłanie faktury
        /// </summary>
        /// <remarks>
        /// Przyjmuje zaszyfrowaną fakturę oraz jej metadane i rozpoczyna jej przetwarzanie.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Wysłanie faktury](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#2-wys%C5%82anie-faktury)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <param name="body">Dane faktury</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SendInvoiceResponse> InvoicesPOSTAsync(string referenceNumber, SendInvoiceRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Wysłanie faktury
        /// </summary>
        /// <remarks>
        /// Przyjmuje zaszyfrowaną fakturę oraz jej metadane i rozpoczyna jej przetwarzanie.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Wysłanie faktury](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#2-wys%C5%82anie-faktury)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <param name="body">Dane faktury</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SendInvoiceResponse> InvoicesPOSTAsync(string referenceNumber, SendInvoiceRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Zamknięcie sesji interaktywnej
        /// </summary>
        /// <remarks>
        /// Zamyka sesję interaktywną i rozpoczyna generowanie zbiorczego UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CloseAsync(string referenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Zamknięcie sesji interaktywnej
        /// </summary>
        /// <remarks>
        /// Zamyka sesję interaktywną i rozpoczyna generowanie zbiorczego UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CloseAsync(string referenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Otwarcie sesji wsadowej
        /// </summary>
        /// <remarks>
        /// Otwiera sesję do wysyłki wsadowej faktur. Należy przekazać schemat wysyłanych faktur, informacje o paczce faktur oraz informacje o kluczu używanym do szyfrowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Przygotwanie paczki faktur](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-wsadowa.md)
        /// <br/>&gt; - [Klucz publiczny Ministersta Finansów](/public-keys/publicKey.pem)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OpenBatchSessionResponse> Batch_openAsync(OpenBatchSessionRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Otwarcie sesji wsadowej
        /// </summary>
        /// <remarks>
        /// Otwiera sesję do wysyłki wsadowej faktur. Należy przekazać schemat wysyłanych faktur, informacje o paczce faktur oraz informacje o kluczu używanym do szyfrowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Przygotwanie paczki faktur](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-wsadowa.md)
        /// <br/>&gt; - [Klucz publiczny Ministersta Finansów](/public-keys/publicKey.pem)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OpenBatchSessionResponse> Batch_openAsync(OpenBatchSessionRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Zamknięcie sesji wsadowej
        /// </summary>
        /// <remarks>
        /// Zamyka sesję wsadową, rozpoczyna procesowanie paczki faktur i generowanie UPO dla prawidłowych faktur oraz zbiorczego UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Close2Async(string referenceNumber);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Zamknięcie sesji wsadowej
        /// </summary>
        /// <remarks>
        /// Zamyka sesję wsadową, rozpoczyna procesowanie paczki faktur i generowanie UPO dla prawidłowych faktur oraz zbiorczego UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task Close2Async(string referenceNumber, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie listy uprawnień do pracy w KSeF nadanych osobom fizycznym lub podmiotom
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień do pracy w KSeF nadanych osobom fizycznym lub podmiotom.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-do-pracy-w-ksef-nadanych-osobom-fizycznym-lub-podmiotom)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryPersonPermissionsResponse> GrantsPOST8Async(int? pageOffset, int? pageSize, PersonPermissionsQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy uprawnień do pracy w KSeF nadanych osobom fizycznym lub podmiotom
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień do pracy w KSeF nadanych osobom fizycznym lub podmiotom.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-do-pracy-w-ksef-nadanych-osobom-fizycznym-lub-podmiotom)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryPersonPermissionsResponse> GrantsPOST8Async(int? pageOffset, int? pageSize, PersonPermissionsQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie listy uprawnień administratorów jednostek i podmiotów podrzędnych
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień administratorów jednostek i podmiotów podrzędnych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-jednostek-i-podmiot%C3%B3w-podrz%C4%99dnych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QuerySubunitPermissionsResponse> GrantsPOST9Async(int? pageOffset, int? pageSize, SubunitPermissionsQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy uprawnień administratorów jednostek i podmiotów podrzędnych
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień administratorów jednostek i podmiotów podrzędnych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-jednostek-i-podmiot%C3%B3w-podrz%C4%99dnych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QuerySubunitPermissionsResponse> GrantsPOST9Async(int? pageOffset, int? pageSize, SubunitPermissionsQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie listy ról podmiotu
        /// </summary>
        /// <remarks>
        /// Zwraca listę ról podmiotu.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy ról](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-r%C3%B3l-podmiotu)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryEntityRolesResponse> RolesGETAsync(int? pageOffset, int? pageSize);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy ról podmiotu
        /// </summary>
        /// <remarks>
        /// Zwraca listę ról podmiotu.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy ról](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-r%C3%B3l-podmiotu)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryEntityRolesResponse> RolesGETAsync(int? pageOffset, int? pageSize, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie listy podmiotów podrzędnych
        /// </summary>
        /// <remarks>
        /// Zwraca liste podmiotów podrzędnych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy podmiotów podrzędnych](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-podmiot%C3%B3w-podrz%C4%99dnych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QuerySubordinateEntityRolesResponse> RolesPOSTAsync(int? pageOffset, int? pageSize, SubordinateEntityRolesQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy podmiotów podrzędnych
        /// </summary>
        /// <remarks>
        /// Zwraca liste podmiotów podrzędnych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy podmiotów podrzędnych](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-podmiot%C3%B3w-podrz%C4%99dnych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QuerySubordinateEntityRolesResponse> RolesPOSTAsync(int? pageOffset, int? pageSize, SubordinateEntityRolesQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie listy uprawnień podmiotowych do obsługi faktur
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień podmiotowych do obsługi faktur.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-podmiotowych-do-obs%C5%82ugi-faktur)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryEntityAuthorizationPermissionsResponse> GrantsPOST10Async(int? pageOffset, int? pageSize, EntityAuthorizationPermissionsQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy uprawnień podmiotowych do obsługi faktur
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień podmiotowych do obsługi faktur.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-podmiotowych-do-obs%C5%82ugi-faktur)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryEntityAuthorizationPermissionsResponse> GrantsPOST10Async(int? pageOffset, int? pageSize, EntityAuthorizationPermissionsQueryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Pobranie listy uprawnień administratorów lub reprezentantów podmiotów unijnych uprawnionych do samofakturowania
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień administratorów lub reprezentantów podmiotów unijnych uprawnionych do samofakturowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-lub-reprezentant%C3%B3w-podmiot%C3%B3w-unijnych-uprawnionych-do-samofakturowania)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `VatUeManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryEuEntityPermissionsResponse> GrantsPOST11Async(int? pageOffset, int? pageSize, EuEntityPermissionsQueryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy uprawnień administratorów lub reprezentantów podmiotów unijnych uprawnionych do samofakturowania
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień administratorów lub reprezentantów podmiotów unijnych uprawnionych do samofakturowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-lub-reprezentant%C3%B3w-podmiot%C3%B3w-unijnych-uprawnionych-do-samofakturowania)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `VatUeManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryEuEntityPermissionsResponse> GrantsPOST11Async(int? pageOffset, int? pageSize, EuEntityPermissionsQueryRequest body, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KsefApiClient : IKsefApiClient
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings, true);
        private Newtonsoft.Json.JsonSerializerSettings _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public KsefApiClient(string baseUrl, System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = baseUrl;
            _httpClient = httpClient;
            Initialize();
        }

        private static Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Pobranie listy aktywnych sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę aktywnych sesji uwierzytelnienia.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AuthenticationListResponse> SessionsGETAsync(string x_continuation_token, int? pageSize)
        {
            return SessionsGETAsync(x_continuation_token, pageSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy aktywnych sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę aktywnych sesji uwierzytelnienia.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AuthenticationListResponse> SessionsGETAsync(string x_continuation_token, int? pageSize, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_continuation_token != null)
                        request_.Headers.TryAddWithoutValidation("x-continuation-token", ConvertToString(x_continuation_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/auth/sessions"
                    urlBuilder_.Append("api/v2/auth/sessions");
                    urlBuilder_.Append('?');
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuthenticationListResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                     | \n|---------------------|-----------------------------------------------------|-------------------------------------------------------------|\n| 21418               | Przekazany token kontynuacji ma nieprawid\u0142owy format. |   |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unieważnienie aktualnej sesji uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Unieważnia sesję powiązaną z tokenem użytym do wywołania tej operacji.
        /// <br/>
        /// <br/>Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można już za jego pomocą uzyskać kolejnych access tokenów.
        /// <br/>**Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `RefreshToken` lub `AccessToken`.
        /// </remarks>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CurrentAsync()
        {
            return CurrentAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unieważnienie aktualnej sesji uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Unieważnia sesję powiązaną z tokenem użytym do wywołania tej operacji.
        /// <br/>
        /// <br/>Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można już za jego pomocą uzyskać kolejnych access tokenów.
        /// <br/>**Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `RefreshToken` lub `AccessToken`.
        /// </remarks>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CurrentAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/auth/sessions/current"
                    urlBuilder_.Append("api/v2/auth/sessions/current");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unieważnienie sesji uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Unieważnia sesję o podanym numerze referencyjnym.
        /// <br/>
        /// <br/>Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można już za jego pomocą uzyskać kolejnych access tokenów.
        /// <br/>**Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji uwierzytelnienia.</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SessionsDELETEAsync(string referenceNumber)
        {
            return SessionsDELETEAsync(referenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unieważnienie sesji uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Unieważnia sesję o podanym numerze referencyjnym.
        /// <br/>
        /// <br/>Unieważnienie sesji sprawia, że powiązany z nią refresh token przestaje działać i nie można już za jego pomocą uzyskać kolejnych access tokenów.
        /// <br/>**Aktywne access tokeny działają do czasu minięcia ich termin ważności.**
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji uwierzytelnienia.</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SessionsDELETEAsync(string referenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/auth/sessions/{referenceNumber}"
                    urlBuilder_.Append("api/v2/auth/sessions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie danych o limitach certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o limitach certyfikatów oraz informacje czy użytkownik może zawnioskować o certyfikat KSeF.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CertificateLimitsResponse> LimitsAsync()
        {
            return LimitsAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie danych o limitach certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o limitach certyfikatów oraz informacje czy użytkownik może zawnioskować o certyfikat KSeF.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CertificateLimitsResponse> LimitsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/certificates/limits"
                    urlBuilder_.Append("api/v2/certificates/limits");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CertificateLimitsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie danych do wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Zwraca dane wymagane do przygotowania wniosku certyfikacyjnego PKCS#10.
        /// <br/>
        /// <br/>Dane te są zwracane na podstawie certyfikatu użytego w procesie uwierzytelnienia i identyfikują podmiot, który składa wniosek o certyfikat.
        /// <br/>
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobranie danych do wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#2-pobranie-danych-do-wniosku-certyfikacyjnego)
        /// <br/>&gt; - [Przygotowanie wniosku](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#3-przygotowanie-csr-certificate-signing-request)
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CertificateEnrollmentDataResponse> DataAsync()
        {
            return DataAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie danych do wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Zwraca dane wymagane do przygotowania wniosku certyfikacyjnego PKCS#10.
        /// <br/>
        /// <br/>Dane te są zwracane na podstawie certyfikatu użytego w procesie uwierzytelnienia i identyfikują podmiot, który składa wniosek o certyfikat.
        /// <br/>
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobranie danych do wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#2-pobranie-danych-do-wniosku-certyfikacyjnego)
        /// <br/>&gt; - [Przygotowanie wniosku](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#3-przygotowanie-csr-certificate-signing-request)
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CertificateEnrollmentDataResponse> DataAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/certificates/enrollments/data"
                    urlBuilder_.Append("api/v2/certificates/enrollments/data");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CertificateEnrollmentDataResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                                                      | Details |\n|---------------------|-------------------------------------------------------------------------------------------|---------|\n| 25001               | Brak mo\u017cliwo\u015bci pobrania danych do CSR dla wykorzystanego sposobu uwierzytelnienia.       |         |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Wysyłka wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Przyjmuje wniosek certyfikacyjny i rozpoczyna jego przetwarzanie.
        /// <br/>
        /// <br/>Dozwolone typy kluczy prywatnych używanych do podpisu wniosku (CSR):
        /// <br/>- RSA (OID: 1.2.840.113549.1.1.1), długość klucza co najmniej 2048 bitów,
        /// <br/>- EC (klucze oparte na krzywych eliptycznych, OID: 1.2.840.10045.2.1), długość klucza co najmniej 256 bitów.
        /// <br/>
        /// <br/>Rekomendowane jest wykorzystywanie kluczy EC.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Wysłanie wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#4-wys%C5%82anie-wniosku-certyfikacyjnego)
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EnrollCertificateResponse> EnrollmentsPOSTAsync(EnrollCertificateRequest body)
        {
            return EnrollmentsPOSTAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Wysyłka wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Przyjmuje wniosek certyfikacyjny i rozpoczyna jego przetwarzanie.
        /// <br/>
        /// <br/>Dozwolone typy kluczy prywatnych używanych do podpisu wniosku (CSR):
        /// <br/>- RSA (OID: 1.2.840.113549.1.1.1), długość klucza co najmniej 2048 bitów,
        /// <br/>- EC (klucze oparte na krzywych eliptycznych, OID: 1.2.840.10045.2.1), długość klucza co najmniej 256 bitów.
        /// <br/>
        /// <br/>Rekomendowane jest wykorzystywanie kluczy EC.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Wysłanie wniosku certyfikacyjnego](https://github.com/CIRFMF/ksef-client-docs/blob/main/certyfikaty-wewn%C4%99trzne-KSeF.md#4-wys%C5%82anie-wniosku-certyfikacyjnego)
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EnrollCertificateResponse> EnrollmentsPOSTAsync(EnrollCertificateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/certificates/enrollments"
                    urlBuilder_.Append("api/v2/certificates/enrollments");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EnrollCertificateResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                                                           | Details |\n|---------------------|------------------------------------------------------------------------------------------------|---------|\n| 25002               | Brak mo\u017cliwo\u015bci z\u0142o\u017cenia wniosku certyfikacyjnego dla wykorzystanego sposobu uwierzytelnienia. |         |\n| 25003               | Dane w CSR nie zgadzaj\u0105 si\u0119 z danymi w u\u017cytym wektorze uwierzytelniaj\u0105cym.                     |         |\n| 25004               | Niepoprawny format CSR lub niepoprawny podpis CSR.                                             |         |\n| 25006               | Osi\u0105gni\u0119to limit mo\u017cliwych do z\u0142o\u017cenia wniosk\u00f3w certyfikacyjnych.                              |         |\n| 25007               | Osi\u0105gni\u0119to limit dopuszczalnej liczby posiadanych certyfikat\u00f3w.                                |         |\n| 25010               | Nieprawid\u0142owy typ lub d\u0142ugo\u015b\u0107 klucza.                                                          |         |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie statusu przetwarzania wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o statusie wniosku certyfikacyjnego.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny wniosku certyfikacyjnego</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CertificateEnrollmentStatusResponse> EnrollmentsGETAsync(string referenceNumber)
        {
            return EnrollmentsGETAsync(referenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu przetwarzania wniosku certyfikacyjnego
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o statusie wniosku certyfikacyjnego.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny wniosku certyfikacyjnego</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CertificateEnrollmentStatusResponse> EnrollmentsGETAsync(string referenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/certificates/enrollments/{referenceNumber}"
                    urlBuilder_.Append("api/v2/certificates/enrollments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CertificateEnrollmentStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                                                           | Details |\n|---------------------|------------------------------------------------------------------------------------------------|---------|\n| 25005               | Wniosek certyfikacyjny o podanym numerze referencyjnym nie istnieje.                           |         |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie certyfikatu lub listy certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca certyfikaty o podanych numerach seryjnych w formacie DER zakodowanym w Base64.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<RetrieveCertificatesResponse> RetrieveAsync(RetrieveCertificatesRequest body)
        {
            return RetrieveAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie certyfikatu lub listy certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca certyfikaty o podanych numerach seryjnych w formacie DER zakodowanym w Base64.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RetrieveCertificatesResponse> RetrieveAsync(RetrieveCertificatesRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/certificates/retrieve"
                    urlBuilder_.Append("api/v2/certificates/retrieve");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RetrieveCertificatesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unieważnienie certyfikatu
        /// </summary>
        /// <remarks>
        /// Unieważnia certyfikat o podanym numerze seryjnym.
        /// </remarks>
        /// <param name="certificateSerialNumber">Numer seryjny certyfikatu (w formacie szesnastkowym).</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RevokeAsync(string certificateSerialNumber, RevokeCertificateRequest body)
        {
            return RevokeAsync(certificateSerialNumber, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unieważnienie certyfikatu
        /// </summary>
        /// <remarks>
        /// Unieważnia certyfikat o podanym numerze seryjnym.
        /// </remarks>
        /// <param name="certificateSerialNumber">Numer seryjny certyfikatu (w formacie szesnastkowym).</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RevokeAsync(string certificateSerialNumber, RevokeCertificateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (certificateSerialNumber == null)
                throw new System.ArgumentNullException("certificateSerialNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/certificates/{certificateSerialNumber}/revoke"
                    urlBuilder_.Append("api/v2/certificates/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(certificateSerialNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/revoke");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                                                           | Details |\n|---------------------|------------------------------------------------------------------------------------------------|---------|\n| 25008               | Certyfikat o podanym numerze seryjnym nie istnieje.                                            |         |\n| 25009               | Nie mo\u017cna odwo\u0142a\u0107 wskazanego certyfikatu, poniewa\u017c jest ju\u017c odwo\u0142any, zablokowany lub niewa\u017cny.|         |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie listy metadanych certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca listę certyfikatów spełniających podane kryteria wyszukiwania.
        /// <br/>W przypadku braku podania kryteriów wyszukiwania zwrócona zostanie nieprzefiltrowana lista.
        /// </remarks>
        /// <param name="pageSize">Rozmiar strony wyników</param>
        /// <param name="pageOffset">Numer strony wyników</param>
        /// <param name="body">Kryteria filtrowania</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<QueryCertificatesResponse> QueryAsync(int? pageSize, int? pageOffset, QueryCertificatesRequest body)
        {
            return QueryAsync(pageSize, pageOffset, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy metadanych certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca listę certyfikatów spełniających podane kryteria wyszukiwania.
        /// <br/>W przypadku braku podania kryteriów wyszukiwania zwrócona zostanie nieprzefiltrowana lista.
        /// </remarks>
        /// <param name="pageSize">Rozmiar strony wyników</param>
        /// <param name="pageOffset">Numer strony wyników</param>
        /// <param name="body">Kryteria filtrowania</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryCertificatesResponse> QueryAsync(int? pageSize, int? pageOffset, QueryCertificatesRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/certificates/query"
                    urlBuilder_.Append("api/v2/certificates/query");
                    urlBuilder_.Append('?');
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (pageOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryCertificatesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o kluczach publicznych używanych do szyfrowania danych przesyłanych do systemu KSeF.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<PublicKeyCertificate>> PublicKeyCertificatesAsync()
        {
            return PublicKeyCertificatesAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie certyfikatów
        /// </summary>
        /// <remarks>
        /// Zwraca informacje o kluczach publicznych używanych do szyfrowania danych przesyłanych do systemu KSeF.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<PublicKeyCertificate>> PublicKeyCertificatesAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/security/public-key-certificates"
                    urlBuilder_.Append("api/v2/security/public-key-certificates");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<PublicKeyCertificate>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Utworzenie podmiotu
        /// </summary>
        /// <remarks>
        /// Tworzenie nowego podmiotu testowego. W przypadku grupy VAT i JST istnieje możliwość stworzenia jednostek podrzędnych. W wyniku takiego działania w systemie powstanie powiązanie między tymi podmiotami.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SubjectAsync(SubjectCreateRequest body)
        {
            return SubjectAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Utworzenie podmiotu
        /// </summary>
        /// <remarks>
        /// Tworzenie nowego podmiotu testowego. W przypadku grupy VAT i JST istnieje możliwość stworzenia jednostek podrzędnych. W wyniku takiego działania w systemie powstanie powiązanie między tymi podmiotami.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SubjectAsync(SubjectCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/testdata/subject"
                    urlBuilder_.Append("api/v2/testdata/subject");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Usunięcie podmiotu
        /// </summary>
        /// <remarks>
        /// Usuwanie podmiotu testowego. W przypadku grupy VAT i JST usunięte zostaną również jednostki podrzędne.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RemoveAsync(SubjectRemoveRequest body)
        {
            return RemoveAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Usunięcie podmiotu
        /// </summary>
        /// <remarks>
        /// Usuwanie podmiotu testowego. W przypadku grupy VAT i JST usunięte zostaną również jednostki podrzędne.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveAsync(SubjectRemoveRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/testdata/subject/remove"
                    urlBuilder_.Append("api/v2/testdata/subject/remove");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Utworzenie osoby fizycznej
        /// </summary>
        /// <remarks>
        /// Tworzenie nowej osoby fizycznej, której system nadaje uprawnienia właścicielskie. Można również określić, czy osoba ta jest komornikiem – wówczas otrzyma odpowiednie uprawnienie egzekucyjne.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PersonAsync(PersonCreateRequest body)
        {
            return PersonAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Utworzenie osoby fizycznej
        /// </summary>
        /// <remarks>
        /// Tworzenie nowej osoby fizycznej, której system nadaje uprawnienia właścicielskie. Można również określić, czy osoba ta jest komornikiem – wówczas otrzyma odpowiednie uprawnienie egzekucyjne.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PersonAsync(PersonCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/testdata/person"
                    urlBuilder_.Append("api/v2/testdata/person");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Usunięcie osoby fizycznej
        /// </summary>
        /// <remarks>
        /// Usuwanie testowej osoby fizycznej. System automatycznie odbierze jej wszystkie uprawnienia.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task Remove2Async(PersonRemoveRequest body)
        {
            return Remove2Async(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Usunięcie osoby fizycznej
        /// </summary>
        /// <remarks>
        /// Usuwanie testowej osoby fizycznej. System automatycznie odbierze jej wszystkie uprawnienia.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task Remove2Async(PersonRemoveRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/testdata/person/remove"
                    urlBuilder_.Append("api/v2/testdata/person/remove");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Nadanie uprawnień testowemu podmiotowi/osobie fizycznej
        /// </summary>
        /// <remarks>
        /// Nadawanie uprawnień testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PermissionsAsync(TestDataPermissionsGrantRequest body)
        {
            return PermissionsAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień testowemu podmiotowi/osobie fizycznej
        /// </summary>
        /// <remarks>
        /// Nadawanie uprawnień testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PermissionsAsync(TestDataPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/testdata/permissions"
                    urlBuilder_.Append("api/v2/testdata/permissions");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Odebranie uprawnień testowemu podmiotowi/osobie fizycznej
        /// </summary>
        /// <remarks>
        /// Odbieranie uprawnień nadanych testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task Revoke2Async(TestDataPermissionsRevokeRequest body)
        {
            return Revoke2Async(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Odebranie uprawnień testowemu podmiotowi/osobie fizycznej
        /// </summary>
        /// <remarks>
        /// Odbieranie uprawnień nadanych testowemu podmiotowi lub osobie fizycznej, a także w ich kontekście.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task Revoke2Async(TestDataPermissionsRevokeRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/testdata/permissions/revoke"
                    urlBuilder_.Append("api/v2/testdata/permissions/revoke");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Umożliwienie wysyłania faktur z załącznikiem
        /// </summary>
        /// <remarks>
        /// Dodaje możliwość wysyłania faktur z załącznikiem przez wskazany podmiot
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task AttachmentAsync(AttachmentPermissionGrantRequest body)
        {
            return AttachmentAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Umożliwienie wysyłania faktur z załącznikiem
        /// </summary>
        /// <remarks>
        /// Dodaje możliwość wysyłania faktur z załącznikiem przez wskazany podmiot
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task AttachmentAsync(AttachmentPermissionGrantRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/testdata/attachment"
                    urlBuilder_.Append("api/v2/testdata/attachment");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Odebranie możliwości wysyłania faktur z załącznikiem
        /// </summary>
        /// <remarks>
        /// Odbiera możliwość wysyłania faktur z załącznikiem przez wskazany podmiot
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task Revoke3Async(AttachmentPermissionRevokeRequest body)
        {
            return Revoke3Async(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Odebranie możliwości wysyłania faktur z załącznikiem
        /// </summary>
        /// <remarks>
        /// Odbiera możliwość wysyłania faktur z załącznikiem przez wskazany podmiot
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task Revoke3Async(AttachmentPermissionRevokeRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/testdata/attachment/revoke"
                    urlBuilder_.Append("api/v2/testdata/attachment/revoke");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Nadanie osobom fizycznym uprawnień do pracy w KSeF
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania osobom fizycznym uprawnień do pracy w KSeF.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadawanie-uprawnie%C5%84-osobom-fizycznym-do-pracy-w-ksef)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOSTAsync(PersonPermissionsGrantRequest body)
        {
            return GrantsPOSTAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie osobom fizycznym uprawnień do pracy w KSeF
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania osobom fizycznym uprawnień do pracy w KSeF.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadawanie-uprawnie%C5%84-osobom-fizycznym-do-pracy-w-ksef)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOSTAsync(PersonPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/persons/grants"
                    urlBuilder_.Append("api/v2/permissions/persons/grants");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermissionsOperationResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Nadanie podmiotom uprawnień do obsługi faktur
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania podmiotom uprawnień do obsługi faktur.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-podmiotom-uprawnie%C5%84-do-obs%C5%82ugi-faktur)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST2Async(EntityPermissionsGrantRequest body)
        {
            return GrantsPOST2Async(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie podmiotom uprawnień do obsługi faktur
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania podmiotom uprawnień do obsługi faktur.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-podmiotom-uprawnie%C5%84-do-obs%C5%82ugi-faktur)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST2Async(EntityPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/entities/grants"
                    urlBuilder_.Append("api/v2/permissions/entities/grants");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermissionsOperationResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Nadanie uprawnień podmiotowych
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień podmiotowych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-podmiotowych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST3Async(EntityAuthorizationPermissionsGrantRequest body)
        {
            return GrantsPOST3Async(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień podmiotowych
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień podmiotowych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-podmiotowych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST3Async(EntityAuthorizationPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/authorizations/grants"
                    urlBuilder_.Append("api/v2/permissions/authorizations/grants");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermissionsOperationResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Nadanie uprawnień w sposób pośredni
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień w sposób pośredni.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-w-spos%C3%B3b-po%C5%9Bredni)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST4Async(IndirectPermissionsGrantRequest body)
        {
            return GrantsPOST4Async(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień w sposób pośredni
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień w sposób pośredni.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-w-spos%C3%B3b-po%C5%9Bredni)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST4Async(IndirectPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/indirect/grants"
                    urlBuilder_.Append("api/v2/permissions/indirect/grants");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermissionsOperationResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Nadanie uprawnień administratora podmiotu podrzędnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień administratora podmiotu podrzędnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-administratora-podmiotu-podrz%C4%99dnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `SubunitManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST5Async(SubunitPermissionsGrantRequest body)
        {
            return GrantsPOST5Async(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień administratora podmiotu podrzędnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień administratora podmiotu podrzędnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-administratora-podmiotu-podrz%C4%99dnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `SubunitManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST5Async(SubunitPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/subunits/grants"
                    urlBuilder_.Append("api/v2/permissions/subunits/grants");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermissionsOperationResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Nadanie uprawnień administratora podmiotu unijnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień administratora podmiotu unijnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-administratora-podmiotu-unijnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST6Async(EuEntityAdministrationPermissionsGrantRequest body)
        {
            return GrantsPOST6Async(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień administratora podmiotu unijnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień administratora podmiotu unijnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-administratora-podmiotu-unijnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST6Async(EuEntityAdministrationPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/eu-entities/administration/grants"
                    urlBuilder_.Append("api/v2/permissions/eu-entities/administration/grants");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermissionsOperationResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Nadanie uprawnień reprezentanta podmiotu unijnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień reprezentanta podmiotu unijnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-reprezentanta-podmiotu-unijnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `VatUeManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST7Async(EuEntityPermissionsGrantRequest body)
        {
            return GrantsPOST7Async(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Nadanie uprawnień reprezentanta podmiotu unijnego
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operację nadawania uprawnień reprezentanta podmiotu unijnego.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Nadawanie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#nadanie-uprawnie%C5%84-reprezentanta-podmiotu-unijnego)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `VatUeManage`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsPOST7Async(EuEntityPermissionsGrantRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/eu-entities/grants"
                    urlBuilder_.Append("api/v2/permissions/eu-entities/grants");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermissionsOperationResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Odebranie uprawnień
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operacje odbierania uprawnienia o podanym identyfikatorze.
        /// <br/>
        /// <br/>Ta metoda służy do odbierania uprawnień takich jak:
        /// <br/>- nadanych nadanych osobom fizycznym lub podmiotom do pracy w KSeF
        /// <br/>- nadanych podmiotom do obsługi faktur
        /// <br/>- nadanych w sposób pośredni
        /// <br/>- administratorów jednostek i podmiotów podrzędnych
        /// <br/>- administratorów podmiotów unijnych uprawnionych do samofakturowania
        /// <br/>- reprezentantów podmiotów unijnych
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#odebranie-uprawnie%C5%84)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="permissionId">Id uprawnienia.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsDELETEAsync(string permissionId)
        {
            return GrantsDELETEAsync(permissionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Odebranie uprawnień
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operacje odbierania uprawnienia o podanym identyfikatorze.
        /// <br/>
        /// <br/>Ta metoda służy do odbierania uprawnień takich jak:
        /// <br/>- nadanych nadanych osobom fizycznym lub podmiotom do pracy w KSeF
        /// <br/>- nadanych podmiotom do obsługi faktur
        /// <br/>- nadanych w sposób pośredni
        /// <br/>- administratorów jednostek i podmiotów podrzędnych
        /// <br/>- administratorów podmiotów unijnych uprawnionych do samofakturowania
        /// <br/>- reprezentantów podmiotów unijnych
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#odebranie-uprawnie%C5%84)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="permissionId">Id uprawnienia.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsDELETEAsync(string permissionId, System.Threading.CancellationToken cancellationToken)
        {
            if (permissionId == null)
                throw new System.ArgumentNullException("permissionId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/common/grants/{permissionId}"
                    urlBuilder_.Append("api/v2/permissions/common/grants/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(permissionId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermissionsOperationResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Odebranie uprawnień podmiotowych
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operacje odbierania uprawnienia o podanym identyfikatorze.
        /// <br/>Ta metoda służy do odbierania uprawnień podmiotowych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#odebranie-uprawnie%C5%84-podmiotowych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="permissionId">Id uprawnienia.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsDELETE2Async(string permissionId)
        {
            return GrantsDELETE2Async(permissionId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Odebranie uprawnień podmiotowych
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczną operacje odbierania uprawnienia o podanym identyfikatorze.
        /// <br/>Ta metoda służy do odbierania uprawnień podmiotowych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Odbieranie uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#odebranie-uprawnie%C5%84-podmiotowych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="permissionId">Id uprawnienia.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermissionsOperationResponse> GrantsDELETE2Async(string permissionId, System.Threading.CancellationToken cancellationToken)
        {
            if (permissionId == null)
                throw new System.ArgumentNullException("permissionId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/authorizations/grants/{permissionId}"
                    urlBuilder_.Append("api/v2/permissions/authorizations/grants/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(permissionId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermissionsOperationResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie statusu operacji
        /// </summary>
        /// <remarks>
        /// Zwraca status operacji asynchronicznej związanej z nadaniem lub odebraniem uprawnień.
        /// </remarks>
        /// <param name="operationReferenceNumber">Numer referencyjny operacji</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermissionsOperationStatusResponse> OperationsAsync(string operationReferenceNumber)
        {
            return OperationsAsync(operationReferenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu operacji
        /// </summary>
        /// <remarks>
        /// Zwraca status operacji asynchronicznej związanej z nadaniem lub odebraniem uprawnień.
        /// </remarks>
        /// <param name="operationReferenceNumber">Numer referencyjny operacji</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermissionsOperationStatusResponse> OperationsAsync(string operationReferenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (operationReferenceNumber == null)
                throw new System.ArgumentNullException("operationReferenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/operations/{operationReferenceNumber}"
                    urlBuilder_.Append("api/v2/permissions/operations/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(operationReferenceNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermissionsOperationStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie faktury po numerze KSeF
        /// </summary>
        /// <remarks>
        /// Zwraca fakturę o podanym numerze KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="ksefNumber">Numer KSeF faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> KsefAsync(string ksefNumber)
        {
            return KsefAsync(ksefNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie faktury po numerze KSeF
        /// </summary>
        /// <remarks>
        /// Zwraca fakturę o podanym numerze KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="ksefNumber">Numer KSeF faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> KsefAsync(string ksefNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (ksefNumber == null)
                throw new System.ArgumentNullException("ksefNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/xml"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/invoices/ksef/{ksefNumber}"
                    urlBuilder_.Append("api/v2/invoices/ksef/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(ksefNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                       | \n|---------------------|-----------------------------------------------------|---------------------------------------------------------------|\n| 21164               | Faktura o podanym identyfikatorze nie istnieje.     | Faktura o numerze KSeF {ksefNumber} nie zosta\u0142a znaleziona.   |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie listy metadanych faktur
        /// </summary>
        /// <remarks>
        /// Zwraca listę metadanych faktur spełniające podane kryteria wyszukiwania.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="pageOffset">Indeks pierwszej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <param name="body">Zestaw filtrów dla wyszukiwania metadanych.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<QueryInvoicesMetadataReponse> MetadataAsync(int? pageOffset, int? pageSize, InvoicesMetadataQueryRequest body)
        {
            return MetadataAsync(pageOffset, pageSize, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy metadanych faktur
        /// </summary>
        /// <remarks>
        /// Zwraca listę metadanych faktur spełniające podane kryteria wyszukiwania.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="pageOffset">Indeks pierwszej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <param name="body">Zestaw filtrów dla wyszukiwania metadanych.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryInvoicesMetadataReponse> MetadataAsync(int? pageOffset, int? pageSize, InvoicesMetadataQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/invoices/query/metadata"
                    urlBuilder_.Append("api/v2/invoices/query/metadata");
                    urlBuilder_.Append('?');
                    if (pageOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryInvoicesMetadataReponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                       | \n|---------------------|-----------------------------------------------------|---------------------------------------------------------------|\n| 21405               | Dokument nie jest zgodny ze schem\u0105 (json).          | {tre\u015b\u0107 b\u0142\u0119du walidacji}                                       |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// [mock] Eksport paczki faktur
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczny proces wyszukiwania faktur w systemie KSeF na podstawie przekazanych filtrów oraz przygotowania ich w formie zaszyfrowanej paczki.
        /// <br/>Wymagane jest przekazanie informacji o szyfrowaniu w polu `Encryption`, które służą do zabezpieczenia przygotowanej paczki z fakturami.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ExportInvoicesResponse> ExportsPOSTAsync(InvoicesExportRequest body)
        {
            return ExportsPOSTAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// [mock] Eksport paczki faktur
        /// </summary>
        /// <remarks>
        /// Rozpoczyna asynchroniczny proces wyszukiwania faktur w systemie KSeF na podstawie przekazanych filtrów oraz przygotowania ich w formie zaszyfrowanej paczki.
        /// <br/>Wymagane jest przekazanie informacji o szyfrowaniu w polu `Encryption`, które służą do zabezpieczenia przygotowanej paczki z fakturami.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ExportInvoicesResponse> ExportsPOSTAsync(InvoicesExportRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/invoices/exports"
                    urlBuilder_.Append("api/v2/invoices/exports");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExportInvoicesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                       | \n|---------------------|-----------------------------------------------------|---------------------------------------------------------------|\n| 21315               | Zalogowany identyfikator kontekstu nie mo\u017ce by\u0107 u\u017cyty dla wybranego podmiotu.     | {tre\u015b\u0107 b\u0142\u0119du walidacji}                                           |\n| 21405               | Dokument nie jest zgodny ze schem\u0105 (json).          | {tre\u015b\u0107 b\u0142\u0119du walidacji}                                       |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// [mock] Pobranie statusu eksportu paczki faktur
        /// </summary>
        /// <remarks>
        /// Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="operationReferenceNumber">Numer referencyjny operacji.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<InvoicesExportStatusResponse> ExportsGETAsync(string operationReferenceNumber)
        {
            return ExportsGETAsync(operationReferenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// [mock] Pobranie statusu eksportu paczki faktur
        /// </summary>
        /// <remarks>
        /// Wymagane uprawnienia: `InvoiceRead`.
        /// </remarks>
        /// <param name="operationReferenceNumber">Numer referencyjny operacji.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InvoicesExportStatusResponse> ExportsGETAsync(string operationReferenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (operationReferenceNumber == null)
                throw new System.ArgumentNullException("operationReferenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/invoices/exports/{operationReferenceNumber}"
                    urlBuilder_.Append("api/v2/invoices/exports/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(operationReferenceNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InvoicesExportStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                       | \n|---------------------|-----------------------------------------------------|---------------------------------------------------------------|\n| 21175               | Wynik zapytania o podanym identyfikatorze nie istnieje.     | {tre\u015b\u0107 z walidatora}                                  |\n| 21405               | Dokument nie jest zgodny ze schem\u0105 (json).          | {tre\u015b\u0107 b\u0142\u0119du walidacji}                                       |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie listy sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę sesji spełniających podane kryteria wyszukiwania.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `Introspection`.
        /// </remarks>
        /// <param name="pageSize">Rozmiar strony.</param>
        /// <param name="sessionType">Typ sesji.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Online | Wysyłka interaktywna (pojedyncze faktury). |
        /// <br/>| Batch | Wysyłka wsadowa (paczka faktur). |</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="dateCreatedFrom">Data utworzenia sesji (od).</param>
        /// <param name="dateCreatedTo">Data utworzenia sesji (do).</param>
        /// <param name="dateClosedFrom">Data zamknięcia sesji (od).</param>
        /// <param name="dateClosedTo">Data zamknięcia sesji (do).</param>
        /// <param name="dateModifiedFrom">Data ostatniej aktywności (wysyłka faktury lub zmiana statusu) w ramach sesji (od).</param>
        /// <param name="dateModifiedTo">Data ostatniej aktywności (wysyłka faktury lub zmiana statusu) w ramach sesji (do).</param>
        /// <param name="statuses">Statusy sesji.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| InProgress | Sesja aktywna. |
        /// <br/>| Succeeded | Sesja przetworzona poprawnie.            W trakcie przetwarzania sesji nie wystąpiły żadne błędy, ale część faktur nadal mogła zostać odrzucona. |
        /// <br/>| Failed | Sesja nie przetworzona z powodu błędów.            Na etapie rozpoczynania lub kończenia sesji wystąpiły błędy, które nie pozwoliły na jej poprawne przetworzenie. |
        /// <br/>| Cancelled | Sesja anulowania.            Został przekroczony czas na wysyłkę w sesji wsadowej, lub nie przesłano żadnych faktur w sesji interaktywnej. |</param>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SessionsQueryResponse> SessionsGET2Async(int? pageSize, SessionType sessionType, string referenceNumber, System.DateTimeOffset? dateCreatedFrom, System.DateTimeOffset? dateCreatedTo, System.DateTimeOffset? dateClosedFrom, System.DateTimeOffset? dateClosedTo, System.DateTimeOffset? dateModifiedFrom, System.DateTimeOffset? dateModifiedTo, System.Collections.Generic.IEnumerable<CommonSessionStatus> statuses, string x_continuation_token)
        {
            return SessionsGET2Async(pageSize, sessionType, referenceNumber, dateCreatedFrom, dateCreatedTo, dateClosedFrom, dateClosedTo, dateModifiedFrom, dateModifiedTo, statuses, x_continuation_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę sesji spełniających podane kryteria wyszukiwania.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `Introspection`.
        /// </remarks>
        /// <param name="pageSize">Rozmiar strony.</param>
        /// <param name="sessionType">Typ sesji.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Online | Wysyłka interaktywna (pojedyncze faktury). |
        /// <br/>| Batch | Wysyłka wsadowa (paczka faktur). |</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="dateCreatedFrom">Data utworzenia sesji (od).</param>
        /// <param name="dateCreatedTo">Data utworzenia sesji (do).</param>
        /// <param name="dateClosedFrom">Data zamknięcia sesji (od).</param>
        /// <param name="dateClosedTo">Data zamknięcia sesji (do).</param>
        /// <param name="dateModifiedFrom">Data ostatniej aktywności (wysyłka faktury lub zmiana statusu) w ramach sesji (od).</param>
        /// <param name="dateModifiedTo">Data ostatniej aktywności (wysyłka faktury lub zmiana statusu) w ramach sesji (do).</param>
        /// <param name="statuses">Statusy sesji.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| InProgress | Sesja aktywna. |
        /// <br/>| Succeeded | Sesja przetworzona poprawnie.            W trakcie przetwarzania sesji nie wystąpiły żadne błędy, ale część faktur nadal mogła zostać odrzucona. |
        /// <br/>| Failed | Sesja nie przetworzona z powodu błędów.            Na etapie rozpoczynania lub kończenia sesji wystąpiły błędy, które nie pozwoliły na jej poprawne przetworzenie. |
        /// <br/>| Cancelled | Sesja anulowania.            Został przekroczony czas na wysyłkę w sesji wsadowej, lub nie przesłano żadnych faktur w sesji interaktywnej. |</param>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SessionsQueryResponse> SessionsGET2Async(int? pageSize, SessionType sessionType, string referenceNumber, System.DateTimeOffset? dateCreatedFrom, System.DateTimeOffset? dateCreatedTo, System.DateTimeOffset? dateClosedFrom, System.DateTimeOffset? dateClosedTo, System.DateTimeOffset? dateModifiedFrom, System.DateTimeOffset? dateModifiedTo, System.Collections.Generic.IEnumerable<CommonSessionStatus> statuses, string x_continuation_token, System.Threading.CancellationToken cancellationToken)
        {
            if (sessionType == null)
                throw new System.ArgumentNullException("sessionType");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_continuation_token != null)
                        request_.Headers.TryAddWithoutValidation("x-continuation-token", ConvertToString(x_continuation_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions"
                    urlBuilder_.Append("api/v2/sessions");
                    urlBuilder_.Append('?');
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Append(System.Uri.EscapeDataString("sessionType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sessionType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (referenceNumber != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("referenceNumber")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (dateCreatedFrom != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("dateCreatedFrom")).Append('=').Append(System.Uri.EscapeDataString(dateCreatedFrom.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (dateCreatedTo != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("dateCreatedTo")).Append('=').Append(System.Uri.EscapeDataString(dateCreatedTo.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (dateClosedFrom != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("dateClosedFrom")).Append('=').Append(System.Uri.EscapeDataString(dateClosedFrom.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (dateClosedTo != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("dateClosedTo")).Append('=').Append(System.Uri.EscapeDataString(dateClosedTo.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (dateModifiedFrom != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("dateModifiedFrom")).Append('=').Append(System.Uri.EscapeDataString(dateModifiedFrom.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (dateModifiedTo != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("dateModifiedTo")).Append('=').Append(System.Uri.EscapeDataString(dateModifiedTo.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (statuses != null)
                    {
                            foreach (var item_ in statuses) { urlBuilder_.Append(System.Uri.EscapeDataString("statuses")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SessionsQueryResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                     | \n|---------------------|-----------------------------------------------------|-------------------------------------------------------------|\n| 21418               | Przekazany token kontynuacji ma nieprawid\u0142owy format. |   |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie statusu sesji
        /// </summary>
        /// <remarks>
        /// Sprawdza bieżący status sesji o podanym numerze referencyjnym.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SessionStatusResponse> SessionsGET3Async(string referenceNumber)
        {
            return SessionsGET3Async(referenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu sesji
        /// </summary>
        /// <remarks>
        /// Sprawdza bieżący status sesji o podanym numerze referencyjnym.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SessionStatusResponse> SessionsGET3Async(string referenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/{referenceNumber}"
                    urlBuilder_.Append("api/v2/sessions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SessionStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                     | \n|---------------------|-----------------------------------------------------|-------------------------------------------------------------|\n| 21173               | Brak sesji o wskazanym numerze referencyjnym.       | Sesja o numerze referencyjnym {referenceNumber} nie zosta\u0142a znaleziona.   |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie faktur sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę faktur przesłanych w sesji wraz z ich statusami, oraz informacje na temat ilości poprawnie i niepoprawnie przetworzonych faktur.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SessionInvoicesResponse> InvoicesGETAsync(string x_continuation_token, string referenceNumber, int? pageSize)
        {
            return InvoicesGETAsync(x_continuation_token, referenceNumber, pageSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie faktur sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę faktur przesłanych w sesji wraz z ich statusami, oraz informacje na temat ilości poprawnie i niepoprawnie przetworzonych faktur.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SessionInvoicesResponse> InvoicesGETAsync(string x_continuation_token, string referenceNumber, int? pageSize, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_continuation_token != null)
                        request_.Headers.TryAddWithoutValidation("x-continuation-token", ConvertToString(x_continuation_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/{referenceNumber}/invoices"
                    urlBuilder_.Append("api/v2/sessions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/invoices");
                    urlBuilder_.Append('?');
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SessionInvoicesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                     | \n|---------------------|-----------------------------------------------------|-------------------------------------------------------------|\n| 21173               | Brak sesji o wskazanym numerze referencyjnym.       | Sesja o numerze referencyjnym {referenceNumber} nie zosta\u0142a znaleziona.   |\n| 21418               | Przekazany token kontynuacji ma nieprawid\u0142owy format. |   |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie statusu faktury z sesji
        /// </summary>
        /// <remarks>
        /// Zwraca fakturę przesłaną w sesji wraz ze statusem.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="invoiceReferenceNumber">Numer referencyjny faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SessionInvoiceStatusResponse> InvoicesGET2Async(string referenceNumber, string invoiceReferenceNumber)
        {
            return InvoicesGET2Async(referenceNumber, invoiceReferenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu faktury z sesji
        /// </summary>
        /// <remarks>
        /// Zwraca fakturę przesłaną w sesji wraz ze statusem.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="invoiceReferenceNumber">Numer referencyjny faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SessionInvoiceStatusResponse> InvoicesGET2Async(string referenceNumber, string invoiceReferenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            if (invoiceReferenceNumber == null)
                throw new System.ArgumentNullException("invoiceReferenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}"
                    urlBuilder_.Append("api/v2/sessions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/invoices/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(invoiceReferenceNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SessionInvoiceStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie niepoprawnie przetworzonych faktur sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę niepoprawnie przetworzonych faktur przesłanych w sesji wraz z ich statusami.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SessionInvoicesResponse> FailedAsync(string x_continuation_token, string referenceNumber, int? pageSize)
        {
            return FailedAsync(x_continuation_token, referenceNumber, pageSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie niepoprawnie przetworzonych faktur sesji
        /// </summary>
        /// <remarks>
        /// Zwraca listę niepoprawnie przetworzonych faktur przesłanych w sesji wraz z ich statusami.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SessionInvoicesResponse> FailedAsync(string x_continuation_token, string referenceNumber, int? pageSize, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_continuation_token != null)
                        request_.Headers.TryAddWithoutValidation("x-continuation-token", ConvertToString(x_continuation_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/{referenceNumber}/invoices/failed"
                    urlBuilder_.Append("api/v2/sessions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/invoices/failed");
                    urlBuilder_.Append('?');
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SessionInvoicesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                     | \n|---------------------|-----------------------------------------------------|-------------------------------------------------------------|\n| 21173               | Brak sesji o wskazanym numerze referencyjnym.       | Sesja o numerze referencyjnym {referenceNumber} nie zosta\u0142a znaleziona.   |\n| 21418               | Przekazany token kontynuacji ma nieprawid\u0142owy format. |   |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie UPO faktury z sesji na podstawie numeru KSeF
        /// </summary>
        /// <remarks>
        /// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="ksefNumber">Numer KSeF faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> UpoAsync(string referenceNumber, string ksefNumber)
        {
            return UpoAsync(referenceNumber, ksefNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie UPO faktury z sesji na podstawie numeru KSeF
        /// </summary>
        /// <remarks>
        /// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="ksefNumber">Numer KSeF faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> UpoAsync(string referenceNumber, string ksefNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            if (ksefNumber == null)
                throw new System.ArgumentNullException("ksefNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/xml"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/{referenceNumber}/invoices/ksef/{ksefNumber}/upo"
                    urlBuilder_.Append("api/v2/sessions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/invoices/ksef/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(ksefNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/upo");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                                                                        | \n|---------------------|-----------------------------------------------------|----------------------------------------------------------------------------------------------------------------|\n| 21178               | Nie znaleziono UPO dla podanych kryteri\u00f3w.          | UPO o numerze KSeF {ksefNumber} i numerze referencyjnym sesji {referenceNumber} nie zosta\u0142o znalezione.  |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie UPO faktury z sesji na podstawie numeru referencyjnego faktury
        /// </summary>
        /// <remarks>
        /// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="invoiceReferenceNumber">Numer referencyjny faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> Upo2Async(string referenceNumber, string invoiceReferenceNumber)
        {
            return Upo2Async(referenceNumber, invoiceReferenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie UPO faktury z sesji na podstawie numeru referencyjnego faktury
        /// </summary>
        /// <remarks>
        /// Zwraca UPO faktury przesłanego w sesji na podstawie jego numeru KSeF.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="invoiceReferenceNumber">Numer referencyjny faktury.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> Upo2Async(string referenceNumber, string invoiceReferenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            if (invoiceReferenceNumber == null)
                throw new System.ArgumentNullException("invoiceReferenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/xml"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/{referenceNumber}/invoices/{invoiceReferenceNumber}/upo"
                    urlBuilder_.Append("api/v2/sessions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/invoices/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(invoiceReferenceNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/upo");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie UPO dla sesji
        /// </summary>
        /// <remarks>
        /// Zwraca XML zawierający zbiorcze UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="upoReferenceNumber">Numer referencyjny UPO.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> Upo3Async(string referenceNumber, string upoReferenceNumber)
        {
            return Upo3Async(referenceNumber, upoReferenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie UPO dla sesji
        /// </summary>
        /// <remarks>
        /// Zwraca XML zawierający zbiorcze UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji.</param>
        /// <param name="upoReferenceNumber">Numer referencyjny UPO.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> Upo3Async(string referenceNumber, string upoReferenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            if (upoReferenceNumber == null)
                throw new System.ArgumentNullException("upoReferenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/xml"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/{referenceNumber}/upo/{upoReferenceNumber}"
                    urlBuilder_.Append("api/v2/sessions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/upo/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(upoReferenceNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                                                                        | \n|---------------------|-----------------------------------------------------|----------------------------------------------------------------------------------------------------------------|\n| 21173               | Brak sesji o wskazanym numerze referencyjnym.       | Sesja o numerze referencyjnym {referenceNumber} nie zosta\u0142a znaleziona.                                        |\n| 21178               | Nie znaleziono UPO dla podanych kryteri\u00f3w.          | UPO o numerze referencyjnym {referenceNumber} dla sesji {referenceNumber} nie zosta\u0142o znalezione.        |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Wygenerowanie nowego tokena
        /// </summary>
        /// <remarks>
        /// Zwraca token, który może być użyty do uwierzytelniania się w KSeF.
        /// <br/>
        /// <br/>Token jest zwracany tylko raz. Zaczyna być aktywny w momencie gdy jego status zmieni się na `Active`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GenerateTokenResponse> TokensPOSTAsync(GenerateTokenRequest body)
        {
            return TokensPOSTAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Wygenerowanie nowego tokena
        /// </summary>
        /// <remarks>
        /// Zwraca token, który może być użyty do uwierzytelniania się w KSeF.
        /// <br/>
        /// <br/>Token jest zwracany tylko raz. Zaczyna być aktywny w momencie gdy jego status zmieni się na `Active`.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GenerateTokenResponse> TokensPOSTAsync(GenerateTokenRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/tokens"
                    urlBuilder_.Append("api/v2/tokens");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GenerateTokenResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                       | Details |\n|---------------------|------------------------------------------------------------|---------|\n| 26001               | Nie mo\u017cna nada\u0107 tokenowi uprawnie\u0144 kt\u00f3rych nie posiadasz.  | Informacja o brakuj\u0105cych uprawnieniach. |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie listy wygenerowanych tokenów
        /// </summary>
        /// <param name="status">Status tokenów do zwrócenia. W przypadku braku parametru zwracane są wszystkie tokeny. Parametr można przekazać wielokrotnie.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Pending | Token został utworzony ale jest jeszcze w trakcie aktywacji i nadawania uprawnień. Nie może być jeszcze wykorzystywany do uwierzytelniania. |
        /// <br/>| Active | Token jest aktywny i może być wykorzystywany do uwierzytelniania. |
        /// <br/>| Revoking | Token jest w trakcie unieważniania. Nie może już być wykorzystywany do uwierzytelniania. |
        /// <br/>| Revoked | Token został unieważniony i nie może być wykorzystywany do uwierzytelniania. |
        /// <br/>| Failed | Nie udało się aktywować tokena. Należy wygenerować nowy token, obecny nie może być wykorzystywany do uwierzytelniania. |</param>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<QueryTokensResponse> TokensGETAsync(System.Collections.Generic.IEnumerable<AuthenticationTokenStatus> status, string x_continuation_token, int? pageSize)
        {
            return TokensGETAsync(status, x_continuation_token, pageSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy wygenerowanych tokenów
        /// </summary>
        /// <param name="status">Status tokenów do zwrócenia. W przypadku braku parametru zwracane są wszystkie tokeny. Parametr można przekazać wielokrotnie.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Pending | Token został utworzony ale jest jeszcze w trakcie aktywacji i nadawania uprawnień. Nie może być jeszcze wykorzystywany do uwierzytelniania. |
        /// <br/>| Active | Token jest aktywny i może być wykorzystywany do uwierzytelniania. |
        /// <br/>| Revoking | Token jest w trakcie unieważniania. Nie może już być wykorzystywany do uwierzytelniania. |
        /// <br/>| Revoked | Token został unieważniony i nie może być wykorzystywany do uwierzytelniania. |
        /// <br/>| Failed | Nie udało się aktywować tokena. Należy wygenerować nowy token, obecny nie może być wykorzystywany do uwierzytelniania. |</param>
        /// <param name="x_continuation_token">Token służący do pobrania kolejnej strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryTokensResponse> TokensGETAsync(System.Collections.Generic.IEnumerable<AuthenticationTokenStatus> status, string x_continuation_token, int? pageSize, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_continuation_token != null)
                        request_.Headers.TryAddWithoutValidation("x-continuation-token", ConvertToString(x_continuation_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/tokens"
                    urlBuilder_.Append("api/v2/tokens");
                    urlBuilder_.Append('?');
                    if (status != null)
                    {
                            foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryTokensResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                     | \n|---------------------|-----------------------------------------------------|-------------------------------------------------------------|\n| 21418               | Przekazany token kontynuacji ma nieprawid\u0142owy format. |   |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie statusu tokena
        /// </summary>
        /// <param name="referenceNumber">Numer referencyjny tokena.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AuthenticationToken> TokensGET2Async(string referenceNumber)
        {
            return TokensGET2Async(referenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu tokena
        /// </summary>
        /// <param name="referenceNumber">Numer referencyjny tokena.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AuthenticationToken> TokensGET2Async(string referenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/tokens/{referenceNumber}"
                    urlBuilder_.Append("api/v2/tokens/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuthenticationToken>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unieważnienie tokena
        /// </summary>
        /// <remarks>
        /// Unieważniony token nie pozwoli już na uwierzytelnienie się za jego pomocą. Unieważnienie nie może zostać cofnięte.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny tokena do unieważeniania.</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task TokensDELETEAsync(string referenceNumber)
        {
            return TokensDELETEAsync(referenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unieważnienie tokena
        /// </summary>
        /// <remarks>
        /// Unieważniony token nie pozwoli już na uwierzytelnienie się za jego pomocą. Unieważnienie nie może zostać cofnięte.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny tokena do unieważeniania.</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task TokensDELETEAsync(string referenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/tokens/{referenceNumber}"
                    urlBuilder_.Append("api/v2/tokens/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Inicjalizacja uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Generuje unikalny challenge wymagany w kolejnym kroku operacji uwierzytelnienia.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AuthenticationChallengeResponse> ChallengeAsync()
        {
            return ChallengeAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Inicjalizacja uwierzytelnienia
        /// </summary>
        /// <remarks>
        /// Generuje unikalny challenge wymagany w kolejnym kroku operacji uwierzytelnienia.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AuthenticationChallengeResponse> ChallengeAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/auth/challenge"
                    urlBuilder_.Append("api/v2/auth/challenge");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuthenticationChallengeResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Uwierzytelnienie z wykorzystaniem podpisu XAdES
        /// </summary>
        /// <remarks>
        /// Rozpoczyna operację uwierzytelniania za pomocą dokumentu XML podpisanego podpisem elektronicznym XAdES.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Przygotowanie dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.md#1-przygotowanie-dokumentu-xml-authtokenrequest)
        /// <br/>&gt; - [Podpis dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.md#2-podpisanie-dokumentu-xades)
        /// <br/>&gt; - [Schemat XSD](/docs/v2/schemas/authv2.xsd)
        /// </remarks>
        /// <param name="verifyCertificateChain">Wymuszenie weryfikacji zaufania łańcucha certyfikatu wraz ze sprawdzeniem statusu certyfikatu (OCSP/CRL) na środowiskach które umożliwiają wykorzystanie samodzielnie wygenerowanych certyfikatów.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AuthenticationInitResponse> XadesSignatureAsync(bool? verifyCertificateChain, string body)
        {
            return XadesSignatureAsync(verifyCertificateChain, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Uwierzytelnienie z wykorzystaniem podpisu XAdES
        /// </summary>
        /// <remarks>
        /// Rozpoczyna operację uwierzytelniania za pomocą dokumentu XML podpisanego podpisem elektronicznym XAdES.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Przygotowanie dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.md#1-przygotowanie-dokumentu-xml-authtokenrequest)
        /// <br/>&gt; - [Podpis dokumentu XML](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.md#2-podpisanie-dokumentu-xades)
        /// <br/>&gt; - [Schemat XSD](/docs/v2/schemas/authv2.xsd)
        /// </remarks>
        /// <param name="verifyCertificateChain">Wymuszenie weryfikacji zaufania łańcucha certyfikatu wraz ze sprawdzeniem statusu certyfikatu (OCSP/CRL) na środowiskach które umożliwiają wykorzystanie samodzielnie wygenerowanych certyfikatów.</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AuthenticationInitResponse> XadesSignatureAsync(bool? verifyCertificateChain, string body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(body);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/xml");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/auth/xades-signature"
                    urlBuilder_.Append("api/v2/auth/xades-signature");
                    urlBuilder_.Append('?');
                    if (verifyCertificateChain != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("verifyCertificateChain")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(verifyCertificateChain, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuthenticationInitResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>(" | ExceptionCode      | ExceptionDescription                                                | Details                                                     | \n|---------------------|---------------------------------------------------------------------|-------------------------------------------------------------|\n| 21001               | Nieczytelna tre\u015b\u0107.                                                  |                                                             |\n| 21111               | Nieprawid\u0142owe wyzwanie autoryzacyjne.                               |                                                             |\n| 21115               | Nieprawid\u0142owy certyfikat.                                           |                                                             |\n| 21117               | Nieprawid\u0142owy identyfikator podmiotu dla wskazanego typu kontekstu. |                                                             |\n| 21217               | Nieprawid\u0142owe kodowanie znak\u00f3w.                                     |                                                             |\n| 21401               | Dokument nie jest zgodny ze schem\u0105 (xsd).                           | {tre\u015b\u0107 b\u0142\u0119du walidacji}                                     |\n| 21406               | Konflikt podpisu i typu uwierzytelnienia.                           |                                                             |\n| 9101                | Nieprawid\u0142owy dokument.                                             |                                                             |\n| 9102                | Brak podpisu.                                                       |                                                             |\n| 9103                | Przekroczona liczba dozwolonych podpis\u00f3w.                           |                                                             |\n| 9105                | Nieprawid\u0142owa tre\u015b\u0107 podpisu.                                        |                                                             |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Uwierzytelnienie z wykorzystaniem tokena KSeF
        /// </summary>
        /// <remarks>
        /// Rozpoczyna operację uwierzytelniania z wykorzystaniem wcześniej wygenerowanego tokena KSeF.
        /// <br/>
        /// <br/>Token KSeF wraz z timestampem ze wcześniej wygenerowanego challenge'a (w formacie ```token|timestamp```) powinien zostać zaszyfrowany dedykowanym do tego celu kluczem publicznym.
        /// <br/>- Timestamp powinien zostać przekazany jako **liczba milisekund od 1 stycznia 1970 roku (Unix timestamp)**.
        /// <br/>- Algorytm szyfrowania: **RSA-OAEP (z użyciem SHA-256 jako funkcji skrótu)**.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AuthenticationInitResponse> KsefTokenAsync(InitTokenAuthenticationRequest body)
        {
            return KsefTokenAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Uwierzytelnienie z wykorzystaniem tokena KSeF
        /// </summary>
        /// <remarks>
        /// Rozpoczyna operację uwierzytelniania z wykorzystaniem wcześniej wygenerowanego tokena KSeF.
        /// <br/>
        /// <br/>Token KSeF wraz z timestampem ze wcześniej wygenerowanego challenge'a (w formacie ```token|timestamp```) powinien zostać zaszyfrowany dedykowanym do tego celu kluczem publicznym.
        /// <br/>- Timestamp powinien zostać przekazany jako **liczba milisekund od 1 stycznia 1970 roku (Unix timestamp)**.
        /// <br/>- Algorytm szyfrowania: **RSA-OAEP (z użyciem SHA-256 jako funkcji skrótu)**.
        /// </remarks>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AuthenticationInitResponse> KsefTokenAsync(InitTokenAuthenticationRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/auth/ksef-token"
                    urlBuilder_.Append("api/v2/auth/ksef-token");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuthenticationInitResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie statusu uwierzytelniania
        /// </summary>
        /// <remarks>
        /// Sprawdza bieżący status operacji uwierzytelniania dla podanego tokena.
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji uwierzytelniania.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny tokena otrzymanego przy inicjalizacji operacji uwierzytelniania.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AuthenticationOperationStatusResponse> AuthAsync(string referenceNumber)
        {
            return AuthAsync(referenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie statusu uwierzytelniania
        /// </summary>
        /// <remarks>
        /// Sprawdza bieżący status operacji uwierzytelniania dla podanego tokena.
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji uwierzytelniania.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny tokena otrzymanego przy inicjalizacji operacji uwierzytelniania.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AuthenticationOperationStatusResponse> AuthAsync(string referenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/auth/{referenceNumber}"
                    urlBuilder_.Append("api/v2/auth/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuthenticationOperationStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie tokenów dostępowych
        /// </summary>
        /// <remarks>
        /// Pobiera parę tokenów (access token i refresh token) wygenerowanych w ramach pozytywnie zakończonego procesu uwierzytelniania.
        /// <br/>**Tokeny można pobrać tylko raz.**
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji uwierzytelniania.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AuthenticationTokensResponse> RedeemAsync()
        {
            return RedeemAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie tokenów dostępowych
        /// </summary>
        /// <remarks>
        /// Pobiera parę tokenów (access token i refresh token) wygenerowanych w ramach pozytywnie zakończonego procesu uwierzytelniania.
        /// <br/>**Tokeny można pobrać tylko raz.**
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `AuthenticationToken` otrzymany przy rozpoczęciu operacji uwierzytelniania.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AuthenticationTokensResponse> RedeemAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/auth/token/redeem"
                    urlBuilder_.Append("api/v2/auth/token/redeem");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuthenticationTokensResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Odświeżenie tokena dostępowego
        /// </summary>
        /// <remarks>
        /// Generuje nowy token dostępu na podstawie ważnego refresh tokena.
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `RefreshToken`.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AuthenticationTokenRefreshResponse> RefreshAsync()
        {
            return RefreshAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Odświeżenie tokena dostępowego
        /// </summary>
        /// <remarks>
        /// Generuje nowy token dostępu na podstawie ważnego refresh tokena.
        /// <br/>
        /// <br/>Sposób uwierzytelnienia: `RefreshToken`.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AuthenticationTokenRefreshResponse> RefreshAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/auth/token/refresh"
                    urlBuilder_.Append("api/v2/auth/token/refresh");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuthenticationTokenRefreshResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                                     | \n|---------------------|-----------------------------------------------------|-----------------------------------------------------------------------------|\n| 21304               | Brak uwierzytelnienia.                              | Operacja uwierzytelniania o numerze referencyjnym {referenceNumber} nie zosta\u0142a znaleziona. |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Otwarcie sesji interaktywnej
        /// </summary>
        /// <remarks>
        /// Otwiera sesję do wysyłki pojedynczych faktur. Należy przekazać schemat wysyłanych faktur oraz informacje o kluczu używanym do szyfrowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Otwarcie sesji interaktywnej](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#1-otwarcie-sesji)
        /// <br/>&gt; - [Klucz publiczny Ministersta Finansów](/public-keys/publicKey.pem)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<OpenOnlineSessionResponse> OnlineSession_openAsync(OpenOnlineSessionRequest body)
        {
            return OnlineSession_openAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Otwarcie sesji interaktywnej
        /// </summary>
        /// <remarks>
        /// Otwiera sesję do wysyłki pojedynczych faktur. Należy przekazać schemat wysyłanych faktur oraz informacje o kluczu używanym do szyfrowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Otwarcie sesji interaktywnej](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#1-otwarcie-sesji)
        /// <br/>&gt; - [Klucz publiczny Ministersta Finansów](/public-keys/publicKey.pem)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OpenOnlineSessionResponse> OnlineSession_openAsync(OpenOnlineSessionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/online"
                    urlBuilder_.Append("api/v2/sessions/online");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OpenOnlineSessionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Wysłanie faktury
        /// </summary>
        /// <remarks>
        /// Przyjmuje zaszyfrowaną fakturę oraz jej metadane i rozpoczyna jej przetwarzanie.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Wysłanie faktury](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#2-wys%C5%82anie-faktury)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <param name="body">Dane faktury</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SendInvoiceResponse> InvoicesPOSTAsync(string referenceNumber, SendInvoiceRequest body)
        {
            return InvoicesPOSTAsync(referenceNumber, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Wysłanie faktury
        /// </summary>
        /// <remarks>
        /// Przyjmuje zaszyfrowaną fakturę oraz jej metadane i rozpoczyna jej przetwarzanie.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Wysłanie faktury](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-interaktywna.md#2-wys%C5%82anie-faktury)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <param name="body">Dane faktury</param>
        /// <returns>Accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SendInvoiceResponse> InvoicesPOSTAsync(string referenceNumber, SendInvoiceRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/online/{referenceNumber}/invoices"
                    urlBuilder_.Append("api/v2/sessions/online/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/invoices");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SendInvoiceResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                                                                    | \n|---------------------|-----------------------------------------------------|------------------------------------------------------------------------------------------------------------|\n| 21173               | Brak sesji o wskazanym numerze referencyjnym.       | Sesja o numerze referencyjnym {referenceNumber} nie zosta\u0142a odnaleziona.                                   |\n| 21154               | Sesja interaktywna zako\u0144czona.                      | Sesja o numerze referencyjnym {referenceNumber} jest zamkni\u0119ta.                                            |\n| 21155               | Przekroczona dozwolona ilo\u015b\u0107 faktur w sesji.        | Sesja o numerze referencyjnym {referenceNumber} osi\u0105gn\u0119\u0142a dozwolony limit liczby faktur {invoiceLimit}.    |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Zamknięcie sesji interaktywnej
        /// </summary>
        /// <remarks>
        /// Zamyka sesję interaktywną i rozpoczyna generowanie zbiorczego UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CloseAsync(string referenceNumber)
        {
            return CloseAsync(referenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Zamknięcie sesji interaktywnej
        /// </summary>
        /// <remarks>
        /// Zamyka sesję interaktywną i rozpoczyna generowanie zbiorczego UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CloseAsync(string referenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/online/{referenceNumber}/close"
                    urlBuilder_.Append("api/v2/sessions/online/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/close");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                                    | \n|---------------------|-----------------------------------------------------|----------------------------------------------------------------------------|\n| 21173               | Brak sesji o wskazanym numerze referencyjnym.       | Sesja o numerze referencyjnym {referenceNumber} nie zosta\u0142a odnaleziona.   |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Otwarcie sesji wsadowej
        /// </summary>
        /// <remarks>
        /// Otwiera sesję do wysyłki wsadowej faktur. Należy przekazać schemat wysyłanych faktur, informacje o paczce faktur oraz informacje o kluczu używanym do szyfrowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Przygotwanie paczki faktur](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-wsadowa.md)
        /// <br/>&gt; - [Klucz publiczny Ministersta Finansów](/public-keys/publicKey.pem)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<OpenBatchSessionResponse> Batch_openAsync(OpenBatchSessionRequest body)
        {
            return Batch_openAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Otwarcie sesji wsadowej
        /// </summary>
        /// <remarks>
        /// Otwiera sesję do wysyłki wsadowej faktur. Należy przekazać schemat wysyłanych faktur, informacje o paczce faktur oraz informacje o kluczu używanym do szyfrowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Przygotwanie paczki faktur](https://github.com/CIRFMF/ksef-docs/blob/main/sesja-wsadowa.md)
        /// <br/>&gt; - [Klucz publiczny Ministersta Finansów](/public-keys/publicKey.pem)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OpenBatchSessionResponse> Batch_openAsync(OpenBatchSessionRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/batch"
                    urlBuilder_.Append("api/v2/sessions/batch");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OpenBatchSessionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                                   | \n|---------------------|-----------------------------------------------------|---------------------------------------------------------------------------|\n| 21157               | Nieprawid\u0142owy rozmiar cz\u0119\u015bci pakietu.               | {tre\u015b\u0107 b\u0142\u0119du walidacji}                                                   | \n| 21161               | Przekroczono dozwolon\u0105 ilo\u015b\u0107 cz\u0119\u015bci pakietu.        | {tre\u015b\u0107 b\u0142\u0119du walidacji}                                                   | \n| 21401               | Dokument nie jest zgodny ze schem\u0105 (json).          | {tre\u015b\u0107 b\u0142\u0119du walidacji}                                                   |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Zamknięcie sesji wsadowej
        /// </summary>
        /// <remarks>
        /// Zamyka sesję wsadową, rozpoczyna procesowanie paczki faktur i generowanie UPO dla prawidłowych faktur oraz zbiorczego UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task Close2Async(string referenceNumber)
        {
            return Close2Async(referenceNumber, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Zamknięcie sesji wsadowej
        /// </summary>
        /// <remarks>
        /// Zamyka sesję wsadową, rozpoczyna procesowanie paczki faktur i generowanie UPO dla prawidłowych faktur oraz zbiorczego UPO dla sesji.
        /// <br/>
        /// <br/>Wymagane uprawnienia: `InvoiceWrite`.
        /// </remarks>
        /// <param name="referenceNumber">Numer referencyjny sesji</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task Close2Async(string referenceNumber, System.Threading.CancellationToken cancellationToken)
        {
            if (referenceNumber == null)
                throw new System.ArgumentNullException("referenceNumber");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/sessions/batch/{referenceNumber}/close"
                    urlBuilder_.Append("api/v2/sessions/batch/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(referenceNumber, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/close");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("| ExceptionCode       | ExceptionDescription                                | Details                                                                   | \n|---------------------|-----------------------------------------------------|---------------------------------------------------------------------------|\n| 21173               | Brak sesji o wskazanym numerze referencyjnym.       | Sesja o numerze referencyjnym {referenceNumber} nie zosta\u0142a znaleziona.   |\n| 21205               | Pakiet nie mo\u017ce by\u0107 pusty.                          | Nie przes\u0142ano zadeklarowanych cz\u0119\u015bci pliku.                               |", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie listy uprawnień do pracy w KSeF nadanych osobom fizycznym lub podmiotom
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień do pracy w KSeF nadanych osobom fizycznym lub podmiotom.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-do-pracy-w-ksef-nadanych-osobom-fizycznym-lub-podmiotom)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<QueryPersonPermissionsResponse> GrantsPOST8Async(int? pageOffset, int? pageSize, PersonPermissionsQueryRequest body)
        {
            return GrantsPOST8Async(pageOffset, pageSize, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy uprawnień do pracy w KSeF nadanych osobom fizycznym lub podmiotom
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień do pracy w KSeF nadanych osobom fizycznym lub podmiotom.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-do-pracy-w-ksef-nadanych-osobom-fizycznym-lub-podmiotom)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryPersonPermissionsResponse> GrantsPOST8Async(int? pageOffset, int? pageSize, PersonPermissionsQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/query/persons/grants"
                    urlBuilder_.Append("api/v2/permissions/query/persons/grants");
                    urlBuilder_.Append('?');
                    if (pageOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryPersonPermissionsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie listy uprawnień administratorów jednostek i podmiotów podrzędnych
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień administratorów jednostek i podmiotów podrzędnych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-jednostek-i-podmiot%C3%B3w-podrz%C4%99dnych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<QuerySubunitPermissionsResponse> GrantsPOST9Async(int? pageOffset, int? pageSize, SubunitPermissionsQueryRequest body)
        {
            return GrantsPOST9Async(pageOffset, pageSize, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy uprawnień administratorów jednostek i podmiotów podrzędnych
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień administratorów jednostek i podmiotów podrzędnych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-jednostek-i-podmiot%C3%B3w-podrz%C4%99dnych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QuerySubunitPermissionsResponse> GrantsPOST9Async(int? pageOffset, int? pageSize, SubunitPermissionsQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/query/subunits/grants"
                    urlBuilder_.Append("api/v2/permissions/query/subunits/grants");
                    urlBuilder_.Append('?');
                    if (pageOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QuerySubunitPermissionsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie listy ról podmiotu
        /// </summary>
        /// <remarks>
        /// Zwraca listę ról podmiotu.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy ról](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-r%C3%B3l-podmiotu)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<QueryEntityRolesResponse> RolesGETAsync(int? pageOffset, int? pageSize)
        {
            return RolesGETAsync(pageOffset, pageSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy ról podmiotu
        /// </summary>
        /// <remarks>
        /// Zwraca listę ról podmiotu.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy ról](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-r%C3%B3l-podmiotu)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryEntityRolesResponse> RolesGETAsync(int? pageOffset, int? pageSize, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/query/entities/roles"
                    urlBuilder_.Append("api/v2/permissions/query/entities/roles");
                    urlBuilder_.Append('?');
                    if (pageOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryEntityRolesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie listy podmiotów podrzędnych
        /// </summary>
        /// <remarks>
        /// Zwraca liste podmiotów podrzędnych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy podmiotów podrzędnych](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-podmiot%C3%B3w-podrz%C4%99dnych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<QuerySubordinateEntityRolesResponse> RolesPOSTAsync(int? pageOffset, int? pageSize, SubordinateEntityRolesQueryRequest body)
        {
            return RolesPOSTAsync(pageOffset, pageSize, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy podmiotów podrzędnych
        /// </summary>
        /// <remarks>
        /// Zwraca liste podmiotów podrzędnych.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy podmiotów podrzędnych](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-podmiot%C3%B3w-podrz%C4%99dnych)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `SubunitManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QuerySubordinateEntityRolesResponse> RolesPOSTAsync(int? pageOffset, int? pageSize, SubordinateEntityRolesQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/query/subordinate-entities/roles"
                    urlBuilder_.Append("api/v2/permissions/query/subordinate-entities/roles");
                    urlBuilder_.Append('?');
                    if (pageOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QuerySubordinateEntityRolesResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie listy uprawnień podmiotowych do obsługi faktur
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień podmiotowych do obsługi faktur.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-podmiotowych-do-obs%C5%82ugi-faktur)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<QueryEntityAuthorizationPermissionsResponse> GrantsPOST10Async(int? pageOffset, int? pageSize, EntityAuthorizationPermissionsQueryRequest body)
        {
            return GrantsPOST10Async(pageOffset, pageSize, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy uprawnień podmiotowych do obsługi faktur
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień podmiotowych do obsługi faktur.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-podmiotowych-do-obs%C5%82ugi-faktur)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryEntityAuthorizationPermissionsResponse> GrantsPOST10Async(int? pageOffset, int? pageSize, EntityAuthorizationPermissionsQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/query/authorizations/grants"
                    urlBuilder_.Append("api/v2/permissions/query/authorizations/grants");
                    urlBuilder_.Append('?');
                    if (pageOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryEntityAuthorizationPermissionsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Pobranie listy uprawnień administratorów lub reprezentantów podmiotów unijnych uprawnionych do samofakturowania
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień administratorów lub reprezentantów podmiotów unijnych uprawnionych do samofakturowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-lub-reprezentant%C3%B3w-podmiot%C3%B3w-unijnych-uprawnionych-do-samofakturowania)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `VatUeManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<QueryEuEntityPermissionsResponse> GrantsPOST11Async(int? pageOffset, int? pageSize, EuEntityPermissionsQueryRequest body)
        {
            return GrantsPOST11Async(pageOffset, pageSize, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Pobranie listy uprawnień administratorów lub reprezentantów podmiotów unijnych uprawnionych do samofakturowania
        /// </summary>
        /// <remarks>
        /// Zwraca listę uprawnień administratorów lub reprezentantów podmiotów unijnych uprawnionych do samofakturowania.
        /// <br/>
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Pobieranie listy uprawnień](https://github.com/CIRFMF/ksef-docs/blob/main/uprawnienia.md#pobranie-listy-uprawnie%C5%84-administrator%C3%B3w-lub-reprezentant%C3%B3w-podmiot%C3%B3w-unijnych-uprawnionych-do-samofakturowania)
        /// <br/>
        /// <br/>Wymagane uprawnienia: `CredentialsManage`, `CredentialsRead`, `VatUeManage`.
        /// </remarks>
        /// <param name="pageOffset">Numer strony wyników.</param>
        /// <param name="pageSize">Rozmiar strony wyników.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryEuEntityPermissionsResponse> GrantsPOST11Async(int? pageOffset, int? pageSize, EuEntityPermissionsQueryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "api/v2/permissions/query/eu-entities/grants"
                    urlBuilder_.Append("api/v2/permissions/query/eu-entities/grants");
                    urlBuilder_.Append('?');
                    if (pageOffset != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageOffset")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageOffset, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (pageSize != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("pageSize")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pageSize, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryEuEntityPermissionsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExceptionResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ExceptionResponse>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AllowedIps
    {

        /// <summary>
        /// Lista adresów IPv4 w notacji dziesiętnej kropkowanej, np. `192.168.0.10`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> IpAddress { get; set; }

        /// <summary>
        /// Lista adresów IPv4 podana w formie zakresu początek–koniec, oddzielonego pojedynczym myślnikiem, np. `10.0.0.1–10.0.0.254`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipRange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> IpRange { get; set; }

        /// <summary>
        /// Lista adresów IPv4 w notacji CIDR z maską 8 / 16 / 24 / 32, np. `172.16.0.0/16`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipMask", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> IpMask { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AmountType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Brutto")]
        Brutto = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Netto")]
        Netto = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Vat")]
        Vat = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AttachmentPermissionGrantRequest
    {

        [Newtonsoft.Json.JsonProperty("nip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nip { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AttachmentPermissionRevokeRequest
    {

        [Newtonsoft.Json.JsonProperty("nip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nip { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthenticationChallengeResponse
    {

        /// <summary>
        /// Unikalny challenge.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("challenge", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Challenge { get; set; }

        /// <summary>
        /// Czas wygenerowania challenge-a.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Timestamp { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthenticationInitResponse
    {

        /// <summary>
        /// Numer referencyjny operacji uwierzytelnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ReferenceNumber { get; set; }

        /// <summary>
        /// Token operacji uwierzytelnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authenticationToken", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TokenInfo AuthenticationToken { get; set; } = new TokenInfo();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthenticationListItem
    {

        /// <summary>
        /// Data rozpoczęcia operacji uwierzytelnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDate { get; set; }

        /// <summary>
        /// Użyta metoda uwierzytelnienia.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Token | Token KSeF. |
        /// <br/>| TrustedProfile | Profil Zaufany. |
        /// <br/>| InternalCertificate | Certyfikat KSeF. |
        /// <br/>| QualifiedSignature | Podpis kwalifikowany. |
        /// <br/>| QualifiedSeal | Pieczęć kwalifikowana. |
        /// <br/>| PersonalSignature | Podpis osobisty. |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authenticationMethod", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AuthenticationMethod AuthenticationMethod { get; set; }

        /// <summary>
        /// Informacje o aktualnym statusie.
        /// <br/>| Code | Description | Details |
        /// <br/>| --- | --- | --- |
        /// <br/>| 100 | Uwierzytelnianie w toku | - |
        /// <br/>| 200 | Uwierzytelnianie zakończone sukcesem | - |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Nieważny certyfikat |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Błąd weryfikacji łańcucha certyfikatów |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Niezaufany łańcuch certyfikatów |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Certyfikat odwołany |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Niepoprawny certyfikat |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Brak przypisanych uprawnień |
        /// <br/>| 401 | Uwierzytelnienie unieważnione | Uwierzytelnienie i powiązane refresh tokeny zostały unieważnione przez użytkownika |
        /// <br/>| 500 | Nieznany błąd | - |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StatusInfo Status { get; set; } = new StatusInfo();

        /// <summary>
        /// Czy został już wydany refresh token powiązany z danym uwierzytelnieniem.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isTokenRedeemed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsTokenRedeemed { get; set; }

        /// <summary>
        /// Data ostatniego odświeżenia tokena.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastTokenRefreshDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastTokenRefreshDate { get; set; }

        /// <summary>
        /// Termin ważności refresh tokena (o ile nie zostanie wcześniej unieważniony).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("refreshTokenValidUntil", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? RefreshTokenValidUntil { get; set; }

        /// <summary>
        /// Numer referencyjny operacji uwierzytelnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ReferenceNumber { get; set; }

        /// <summary>
        /// Czy sesja jest powiązana z aktualnie używanym tokenem.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isCurrent", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsCurrent { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthenticationListResponse
    {

        /// <summary>
        /// Token służący do pobrania kolejnej strony wyników. Jeśli jest pusty, to nie ma kolejnych stron.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("continuationToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContinuationToken { get; set; }

        /// <summary>
        /// Lista sesji uwierzytelniania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<AuthenticationListItem> Items { get; set; } = new System.Collections.ObjectModel.Collection<AuthenticationListItem>();

    }

    /// <summary>
    /// Metoda uwierzytelnienia.
    /// <br/>| Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| Token | Token KSeF. |
    /// <br/>| TrustedProfile | Profil Zaufany. |
    /// <br/>| InternalCertificate | Certyfikat KSeF. |
    /// <br/>| QualifiedSignature | Podpis kwalifikowany. |
    /// <br/>| QualifiedSeal | Pieczęć kwalifikowana. |
    /// <br/>| PersonalSignature | Podpis osobisty. |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AuthenticationMethod
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Token")]
        Token = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"TrustedProfile")]
        TrustedProfile = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"InternalCertificate")]
        InternalCertificate = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"QualifiedSignature")]
        QualifiedSignature = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"QualifiedSeal")]
        QualifiedSeal = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"PersonalSignature")]
        PersonalSignature = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthenticationOperationStatusResponse
    {

        /// <summary>
        /// Data rozpoczęcia operacji uwierzytelnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDate { get; set; }

        /// <summary>
        /// Użyta metoda uwierzytelnienia.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Token | Token KSeF. |
        /// <br/>| TrustedProfile | Profil Zaufany. |
        /// <br/>| InternalCertificate | Certyfikat KSeF. |
        /// <br/>| QualifiedSignature | Podpis kwalifikowany. |
        /// <br/>| QualifiedSeal | Pieczęć kwalifikowana. |
        /// <br/>| PersonalSignature | Podpis osobisty. |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authenticationMethod", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AuthenticationMethod AuthenticationMethod { get; set; }

        /// <summary>
        /// Informacje o aktualnym statusie.
        /// <br/>| Code | Description | Details |
        /// <br/>| --- | --- | --- |
        /// <br/>| 100 | Uwierzytelnianie w toku | - |
        /// <br/>| 200 | Uwierzytelnianie zakończone sukcesem | - |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Nieważny certyfikat |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Błąd weryfikacji łańcucha certyfikatów |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Niezaufany łańcuch certyfikatów |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Certyfikat odwołany |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Niepoprawny certyfikat |
        /// <br/>| 400 | Uwierzytelnianie zakończone niepowodzeniem | Brak przypisanych uprawnień |
        /// <br/>| 401 | Uwierzytelnienie unieważnione | Uwierzytelnienie i powiązane refresh tokeny zostały unieważnione przez użytkownika |
        /// <br/>| 500 | Nieznany błąd | - |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StatusInfo Status { get; set; } = new StatusInfo();

        /// <summary>
        /// Czy został już wydany refresh token powiązany z danym uwierzytelnieniem.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isTokenRedeemed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsTokenRedeemed { get; set; }

        /// <summary>
        /// Data ostatniego odświeżenia tokena.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastTokenRefreshDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastTokenRefreshDate { get; set; }

        /// <summary>
        /// Termin ważności refresh tokena (o ile nie zostanie wcześniej unieważniony).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("refreshTokenValidUntil", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? RefreshTokenValidUntil { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthenticationToken
    {

        /// <summary>
        /// Numer referencyjny tokena.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReferenceNumber { get; set; }

        /// <summary>
        /// Identyfikator osoby która wygenerowała token.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubjectIdentifier AuthorIdentifier { get; set; }

        /// <summary>
        /// Identyfikator kontekstu, w którym został wygenerowany token i do którego daje dostęp.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContextIdentifier ContextIdentifier { get; set; }

        /// <summary>
        /// Opis tokena.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Uprawnienia przypisane tokenowi.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestedPermissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<TokenPermissionType> RequestedPermissions { get; set; }

        /// <summary>
        /// Data i czas utworzenia tokena.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dateCreated", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset DateCreated { get; set; }

        /// <summary>
        /// Status tokena.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Pending | Token został utworzony ale jest jeszcze w trakcie aktywacji i nadawania uprawnień. Nie może być jeszcze wykorzystywany do uwierzytelniania. |
        /// <br/>| Active | Token jest aktywny i może być wykorzystywany do uwierzytelniania. |
        /// <br/>| Revoking | Token jest w trakcie unieważniania. Nie może już być wykorzystywany do uwierzytelniania. |
        /// <br/>| Revoked | Token został unieważniony i nie może być wykorzystywany do uwierzytelniania. |
        /// <br/>| Failed | Nie udało się aktywować tokena. Należy wygenerować nowy token, obecny nie może być wykorzystywany do uwierzytelniania. |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AuthenticationTokenStatus Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthenticationTokenRefreshResponse
    {

        /// <summary>
        /// Token dostępu, którego należy używać w wywołaniach chronionych zasobów API.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessToken", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TokenInfo AccessToken { get; set; } = new TokenInfo();

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| Pending | Token został utworzony ale jest jeszcze w trakcie aktywacji i nadawania uprawnień. Nie może być jeszcze wykorzystywany do uwierzytelniania. |
    /// <br/>| Active | Token jest aktywny i może być wykorzystywany do uwierzytelniania. |
    /// <br/>| Revoking | Token jest w trakcie unieważniania. Nie może już być wykorzystywany do uwierzytelniania. |
    /// <br/>| Revoked | Token został unieważniony i nie może być wykorzystywany do uwierzytelniania. |
    /// <br/>| Failed | Nie udało się aktywować tokena. Należy wygenerować nowy token, obecny nie może być wykorzystywany do uwierzytelniania. |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AuthenticationTokenStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Pending")]
        Pending = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Active")]
        Active = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Revoking")]
        Revoking = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Revoked")]
        Revoked = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Failed")]
        Failed = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthenticationTokensResponse
    {

        /// <summary>
        /// Token dostępu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessToken", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TokenInfo AccessToken { get; set; } = new TokenInfo();

        /// <summary>
        /// Token umożliwiający odświeżenie tokenu dostępu.
        /// <br/>&gt; Więcej informacji:
        /// <br/>&gt; - [Odświeżanie tokena](https://github.com/CIRFMF/ksef-docs/blob/main/uwierzytelnianie.md#od%C5%9Bwie%C5%BCenie-tokena-accesstoken)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("refreshToken", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public TokenInfo RefreshToken { get; set; } = new TokenInfo();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BatchFileInfo
    {

        /// <summary>
        /// Rozmiar pliku paczki w bajtach. Maksymalny rozmiar paczki to 5GB (5_368_709_120 bajtów).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileSize", Required = Newtonsoft.Json.Required.Always)]
        public long FileSize { get; set; }

        /// <summary>
        /// Skrót SHA256 pliku paczki, zakodowany w formacie Base64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileHash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FileHash { get; set; }

        /// <summary>
        /// Informacje o częściach pliku paczki. Maksymalna ilość części to 50.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileParts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<BatchFilePartInfo> FileParts { get; set; } = new System.Collections.ObjectModel.Collection<BatchFilePartInfo>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BatchFilePartInfo
    {

        /// <summary>
        /// Numer sekwencyjny części pliku paczki.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ordinalNumber", Required = Newtonsoft.Json.Required.Always)]
        public int OrdinalNumber { get; set; }

        /// <summary>
        /// Nazwa części pliku paczki.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FileName { get; set; }

        /// <summary>
        /// Rozmiar części pliku paczki w bajtach. Maksymalna dozwolona wartość to 100MB (104_857_600 bajtów).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileSize", Required = Newtonsoft.Json.Required.Always)]
        public long FileSize { get; set; }

        /// <summary>
        /// Skrót SHA256 części pliku paczki, zakodowany w formacie Base64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileHash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FileHash { get; set; }

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| None | Brak identyfikatora nabywcy |
    /// <br/>| Other | Inny |
    /// <br/>| Nip | NIP |
    /// <br/>| VatUe | VAT UE |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum BuyerIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"VatUe")]
        VatUe = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CertificateEnrollmentDataResponse
    {

        /// <summary>
        /// Nazwa powszechna.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("commonName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CommonName { get; set; }

        /// <summary>
        /// Kraj, kod ISO 3166.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("countryName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CountryName { get; set; }

        /// <summary>
        /// Imiona.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("givenNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> GivenNames { get; set; }

        /// <summary>
        /// Nazwisko.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("surname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Surname { get; set; }

        /// <summary>
        /// Numer seryjny podmiotu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serialNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SerialNumber { get; set; }

        /// <summary>
        /// Unikalny identyfikator.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uniqueIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UniqueIdentifier { get; set; }

        /// <summary>
        /// Nazwa organizacji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("organizationName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OrganizationName { get; set; }

        /// <summary>
        /// Identyfikator organizacji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("organizationIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OrganizationIdentifier { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CertificateEnrollmentStatusResponse
    {

        /// <summary>
        /// Data złożenia wniosku certyfikacyjnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requestDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset RequestDate { get; set; }

        /// <summary>
        /// Informacje o aktualnym statusie.
        /// <br/>| Code | Description | Details |
        /// <br/>| --- | --- | --- |
        /// <br/>| 100 | Wniosek przyjęty do realizacji | - |
        /// <br/>| 200 | Wniosek obsłużony (certyfikat wygenerowany) | - |
        /// <br/>| 400 | Wniosek odrzucony | Klucz publiczny został już certyfikowany przez inny podmiot. |
        /// <br/>| 400 | Wniosek odrzucony | Osiągnięto dopuszczalny limit posiadanych certyfikatów. |
        /// <br/>| 500 | Nieznany błąd | - |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StatusInfo Status { get; set; } = new StatusInfo();

        /// <summary>
        /// Numer seryjny wygenerowanego certyfikatu (w formacie szesnastkowym). 
        /// <br/>Zwracany w przypadku prawidłowego przeprocesowania wniosku certyfikacyjnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificateSerialNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CertificateSerialNumber { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CertificateLimit
    {

        /// <summary>
        /// Pozostała wartość limitu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remaining", Required = Newtonsoft.Json.Required.Always)]
        public int Remaining { get; set; }

        /// <summary>
        /// Maksymalna liczba zasobów dozwolona w ramach limitu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("limit", Required = Newtonsoft.Json.Required.Always)]
        public int Limit { get; set; }

    }

    /// <summary>
    /// Informacje o limitach wniosków oraz certyfikatów dla uwierzytelnionego podmiotu.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CertificateLimitsResponse
    {

        /// <summary>
        /// Flaga informująca czy uwierzytelniony podmiot może złożyć nowy wniosek o certyfikat.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("canRequest", Required = Newtonsoft.Json.Required.Always)]
        public bool CanRequest { get; set; }

        /// <summary>
        /// Informacje o limitach związanych z liczbą możliwych do złożenia wniosków certyfikacyjnych.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enrollment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CertificateLimit Enrollment { get; set; } = new CertificateLimit();

        /// <summary>
        /// Informacje o limitach dotyczących liczby aktywnych certyfikatów wydanych dla danego podmiotu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CertificateLimit Certificate { get; set; } = new CertificateLimit();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CertificateListItem
    {

        /// <summary>
        /// Numer seryjny certyfikatu (w formacie szesnastkowym).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificateSerialNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CertificateSerialNumber { get; set; }

        /// <summary>
        /// Nazwa własna certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Typ certyfikatu.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Authentication | Certyfikat używany do uwierzytelnienia w systemie. |
        /// <br/>| Offline | Certyfikat używany wyłącznie do potwierdzania autentyczności wystawcy i integralności faktury w trybie offline |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KsefCertificateType Type { get; set; }

        /// <summary>
        /// Nazwa powszechna (CN) podmiotu, dla którego wystawiono certyfikat.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("commonName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CommonName { get; set; }

        /// <summary>
        /// Status certyfikatu.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Active | Certyfikat jest aktywny i może zostać użyty do uwierzytelnienia lub realizacji operacji w trybie offline (w zależności od typu certyfikatu). |
        /// <br/>| Blocked | Certyfikat został zablokowany i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline.            Status przejściowy do czasu zakończenia procesu unieważniania. |
        /// <br/>| Revoked | Certyfikat został unieważniony i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline. |
        /// <br/>| Expired | Certyfikat wygasł i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline. |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CertificateListItemStatus Status { get; set; }

        /// <summary>
        /// Identyfikator podmiotu, dla którego wystawiono certyfikat.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SubjectIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora podmiotu, dla którego wystawiono certyfikat.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectIdentifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SubjectIdentifierType { get; set; }

        /// <summary>
        /// Data rozpoczęcia ważności certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validFrom", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ValidFrom { get; set; }

        /// <summary>
        /// Data wygaśnięcia certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validTo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ValidTo { get; set; }

        /// <summary>
        /// Data ostatniego użycia certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastUseDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastUseDate { get; set; }

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| Active | Certyfikat jest aktywny i może zostać użyty do uwierzytelnienia lub realizacji operacji w trybie offline (w zależności od typu certyfikatu). |
    /// <br/>| Blocked | Certyfikat został zablokowany i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline.            Status przejściowy do czasu zakończenia procesu unieważniania. |
    /// <br/>| Revoked | Certyfikat został unieważniony i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline. |
    /// <br/>| Expired | Certyfikat wygasł i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline. |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CertificateListItemStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Active")]
        Active = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Blocked")]
        Blocked = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Revoked")]
        Revoked = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Expired")]
        Expired = 3,

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| Unspecified | Nieokreślony. |
    /// <br/>| Superseded | Certyfikat został zastąpiony przez inny. |
    /// <br/>| KeyCompromise | Klucz prywatny powiązany z certyfikatem został skompromitowany. |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CertificateRevocationReason
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Unspecified")]
        Unspecified = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Superseded")]
        Superseded = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"KeyCompromise")]
        KeyCompromise = 2,

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| InProgress | Sesja aktywna. |
    /// <br/>| Succeeded | Sesja przetworzona poprawnie.            W trakcie przetwarzania sesji nie wystąpiły żadne błędy, ale część faktur nadal mogła zostać odrzucona. |
    /// <br/>| Failed | Sesja nie przetworzona z powodu błędów.            Na etapie rozpoczynania lub kończenia sesji wystąpiły błędy, które nie pozwoliły na jej poprawne przetworzenie. |
    /// <br/>| Cancelled | Sesja anulowania.            Został przekroczony czas na wysyłkę w sesji wsadowej, lub nie przesłano żadnych faktur w sesji interaktywnej. |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CommonSessionStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"InProgress")]
        InProgress = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Succeeded")]
        Succeeded = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Failed")]
        Failed = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Cancelled")]
        Cancelled = 3,

    }

    /// <summary>
    /// Identyfikator kontekstu działania.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// <br/>| InternalId | Dwuczłonowy identyfikator składający się z numeru NIP i 5 cyfr: `{nip}-{5_cyfr}` |
    /// <br/>| NipVatUe | Dwuczłonowy identyfikator składający się z numeru NIP i numeru VAT-UE: `{nip}-{vat_ue}` |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContextIdentifier
    {

        /// <summary>
        /// Typ identyfikatora
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContextIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ContextIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AllPartners")]
        AllPartners = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"InternalId")]
        InternalId = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"NipVatUe")]
        NipVatUe = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CurrencyCode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AED")]
        AED = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AFN")]
        AFN = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"ALL")]
        ALL = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"AMD")]
        AMD = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"ANG")]
        ANG = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"AOA")]
        AOA = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"ARS")]
        ARS = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"AUD")]
        AUD = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"AWG")]
        AWG = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"AZN")]
        AZN = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"BAM")]
        BAM = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"BBD")]
        BBD = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"BDT")]
        BDT = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"BGN")]
        BGN = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"BHD")]
        BHD = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"BIF")]
        BIF = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"BMD")]
        BMD = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"BND")]
        BND = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"BOB")]
        BOB = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"BOV")]
        BOV = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"BRL")]
        BRL = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"BSD")]
        BSD = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"BTN")]
        BTN = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"BWP")]
        BWP = 23,

        [System.Runtime.Serialization.EnumMember(Value = @"BYN")]
        BYN = 24,

        [System.Runtime.Serialization.EnumMember(Value = @"BZD")]
        BZD = 25,

        [System.Runtime.Serialization.EnumMember(Value = @"CAD")]
        CAD = 26,

        [System.Runtime.Serialization.EnumMember(Value = @"CDF")]
        CDF = 27,

        [System.Runtime.Serialization.EnumMember(Value = @"CHE")]
        CHE = 28,

        [System.Runtime.Serialization.EnumMember(Value = @"CHF")]
        CHF = 29,

        [System.Runtime.Serialization.EnumMember(Value = @"CHW")]
        CHW = 30,

        [System.Runtime.Serialization.EnumMember(Value = @"CLF")]
        CLF = 31,

        [System.Runtime.Serialization.EnumMember(Value = @"CLP")]
        CLP = 32,

        [System.Runtime.Serialization.EnumMember(Value = @"CNY")]
        CNY = 33,

        [System.Runtime.Serialization.EnumMember(Value = @"COP")]
        COP = 34,

        [System.Runtime.Serialization.EnumMember(Value = @"COU")]
        COU = 35,

        [System.Runtime.Serialization.EnumMember(Value = @"CRC")]
        CRC = 36,

        [System.Runtime.Serialization.EnumMember(Value = @"CUC")]
        CUC = 37,

        [System.Runtime.Serialization.EnumMember(Value = @"CUP")]
        CUP = 38,

        [System.Runtime.Serialization.EnumMember(Value = @"CVE")]
        CVE = 39,

        [System.Runtime.Serialization.EnumMember(Value = @"CZK")]
        CZK = 40,

        [System.Runtime.Serialization.EnumMember(Value = @"DJF")]
        DJF = 41,

        [System.Runtime.Serialization.EnumMember(Value = @"DKK")]
        DKK = 42,

        [System.Runtime.Serialization.EnumMember(Value = @"DOP")]
        DOP = 43,

        [System.Runtime.Serialization.EnumMember(Value = @"DZD")]
        DZD = 44,

        [System.Runtime.Serialization.EnumMember(Value = @"EGP")]
        EGP = 45,

        [System.Runtime.Serialization.EnumMember(Value = @"ERN")]
        ERN = 46,

        [System.Runtime.Serialization.EnumMember(Value = @"ETB")]
        ETB = 47,

        [System.Runtime.Serialization.EnumMember(Value = @"EUR")]
        EUR = 48,

        [System.Runtime.Serialization.EnumMember(Value = @"FJD")]
        FJD = 49,

        [System.Runtime.Serialization.EnumMember(Value = @"FKP")]
        FKP = 50,

        [System.Runtime.Serialization.EnumMember(Value = @"GBP")]
        GBP = 51,

        [System.Runtime.Serialization.EnumMember(Value = @"GEL")]
        GEL = 52,

        [System.Runtime.Serialization.EnumMember(Value = @"GGP")]
        GGP = 53,

        [System.Runtime.Serialization.EnumMember(Value = @"GHS")]
        GHS = 54,

        [System.Runtime.Serialization.EnumMember(Value = @"GIP")]
        GIP = 55,

        [System.Runtime.Serialization.EnumMember(Value = @"GMD")]
        GMD = 56,

        [System.Runtime.Serialization.EnumMember(Value = @"GNF")]
        GNF = 57,

        [System.Runtime.Serialization.EnumMember(Value = @"GTQ")]
        GTQ = 58,

        [System.Runtime.Serialization.EnumMember(Value = @"GYD")]
        GYD = 59,

        [System.Runtime.Serialization.EnumMember(Value = @"HKD")]
        HKD = 60,

        [System.Runtime.Serialization.EnumMember(Value = @"HNL")]
        HNL = 61,

        [System.Runtime.Serialization.EnumMember(Value = @"HRK")]
        HRK = 62,

        [System.Runtime.Serialization.EnumMember(Value = @"HTG")]
        HTG = 63,

        [System.Runtime.Serialization.EnumMember(Value = @"HUF")]
        HUF = 64,

        [System.Runtime.Serialization.EnumMember(Value = @"IDR")]
        IDR = 65,

        [System.Runtime.Serialization.EnumMember(Value = @"ILS")]
        ILS = 66,

        [System.Runtime.Serialization.EnumMember(Value = @"IMP")]
        IMP = 67,

        [System.Runtime.Serialization.EnumMember(Value = @"INR")]
        INR = 68,

        [System.Runtime.Serialization.EnumMember(Value = @"IQD")]
        IQD = 69,

        [System.Runtime.Serialization.EnumMember(Value = @"IRR")]
        IRR = 70,

        [System.Runtime.Serialization.EnumMember(Value = @"ISK")]
        ISK = 71,

        [System.Runtime.Serialization.EnumMember(Value = @"JEP")]
        JEP = 72,

        [System.Runtime.Serialization.EnumMember(Value = @"JMD")]
        JMD = 73,

        [System.Runtime.Serialization.EnumMember(Value = @"JOD")]
        JOD = 74,

        [System.Runtime.Serialization.EnumMember(Value = @"JPY")]
        JPY = 75,

        [System.Runtime.Serialization.EnumMember(Value = @"KES")]
        KES = 76,

        [System.Runtime.Serialization.EnumMember(Value = @"KGS")]
        KGS = 77,

        [System.Runtime.Serialization.EnumMember(Value = @"KHR")]
        KHR = 78,

        [System.Runtime.Serialization.EnumMember(Value = @"KMF")]
        KMF = 79,

        [System.Runtime.Serialization.EnumMember(Value = @"KPW")]
        KPW = 80,

        [System.Runtime.Serialization.EnumMember(Value = @"KRW")]
        KRW = 81,

        [System.Runtime.Serialization.EnumMember(Value = @"KWD")]
        KWD = 82,

        [System.Runtime.Serialization.EnumMember(Value = @"KYD")]
        KYD = 83,

        [System.Runtime.Serialization.EnumMember(Value = @"KZT")]
        KZT = 84,

        [System.Runtime.Serialization.EnumMember(Value = @"LAK")]
        LAK = 85,

        [System.Runtime.Serialization.EnumMember(Value = @"LBP")]
        LBP = 86,

        [System.Runtime.Serialization.EnumMember(Value = @"LKR")]
        LKR = 87,

        [System.Runtime.Serialization.EnumMember(Value = @"LRD")]
        LRD = 88,

        [System.Runtime.Serialization.EnumMember(Value = @"LSL")]
        LSL = 89,

        [System.Runtime.Serialization.EnumMember(Value = @"LYD")]
        LYD = 90,

        [System.Runtime.Serialization.EnumMember(Value = @"MAD")]
        MAD = 91,

        [System.Runtime.Serialization.EnumMember(Value = @"MDL")]
        MDL = 92,

        [System.Runtime.Serialization.EnumMember(Value = @"MGA")]
        MGA = 93,

        [System.Runtime.Serialization.EnumMember(Value = @"MKD")]
        MKD = 94,

        [System.Runtime.Serialization.EnumMember(Value = @"MMK")]
        MMK = 95,

        [System.Runtime.Serialization.EnumMember(Value = @"MNT")]
        MNT = 96,

        [System.Runtime.Serialization.EnumMember(Value = @"MOP")]
        MOP = 97,

        [System.Runtime.Serialization.EnumMember(Value = @"MRU")]
        MRU = 98,

        [System.Runtime.Serialization.EnumMember(Value = @"MUR")]
        MUR = 99,

        [System.Runtime.Serialization.EnumMember(Value = @"MVR")]
        MVR = 100,

        [System.Runtime.Serialization.EnumMember(Value = @"MWK")]
        MWK = 101,

        [System.Runtime.Serialization.EnumMember(Value = @"MXN")]
        MXN = 102,

        [System.Runtime.Serialization.EnumMember(Value = @"MXV")]
        MXV = 103,

        [System.Runtime.Serialization.EnumMember(Value = @"MYR")]
        MYR = 104,

        [System.Runtime.Serialization.EnumMember(Value = @"MZN")]
        MZN = 105,

        [System.Runtime.Serialization.EnumMember(Value = @"NAD")]
        NAD = 106,

        [System.Runtime.Serialization.EnumMember(Value = @"NGN")]
        NGN = 107,

        [System.Runtime.Serialization.EnumMember(Value = @"NIO")]
        NIO = 108,

        [System.Runtime.Serialization.EnumMember(Value = @"NOK")]
        NOK = 109,

        [System.Runtime.Serialization.EnumMember(Value = @"NPR")]
        NPR = 110,

        [System.Runtime.Serialization.EnumMember(Value = @"NZD")]
        NZD = 111,

        [System.Runtime.Serialization.EnumMember(Value = @"OMR")]
        OMR = 112,

        [System.Runtime.Serialization.EnumMember(Value = @"PAB")]
        PAB = 113,

        [System.Runtime.Serialization.EnumMember(Value = @"PEN")]
        PEN = 114,

        [System.Runtime.Serialization.EnumMember(Value = @"PGK")]
        PGK = 115,

        [System.Runtime.Serialization.EnumMember(Value = @"PHP")]
        PHP = 116,

        [System.Runtime.Serialization.EnumMember(Value = @"PKR")]
        PKR = 117,

        [System.Runtime.Serialization.EnumMember(Value = @"PLN")]
        PLN = 118,

        [System.Runtime.Serialization.EnumMember(Value = @"PYG")]
        PYG = 119,

        [System.Runtime.Serialization.EnumMember(Value = @"QAR")]
        QAR = 120,

        [System.Runtime.Serialization.EnumMember(Value = @"RON")]
        RON = 121,

        [System.Runtime.Serialization.EnumMember(Value = @"RSD")]
        RSD = 122,

        [System.Runtime.Serialization.EnumMember(Value = @"RUB")]
        RUB = 123,

        [System.Runtime.Serialization.EnumMember(Value = @"RWF")]
        RWF = 124,

        [System.Runtime.Serialization.EnumMember(Value = @"SAR")]
        SAR = 125,

        [System.Runtime.Serialization.EnumMember(Value = @"SBD")]
        SBD = 126,

        [System.Runtime.Serialization.EnumMember(Value = @"SCR")]
        SCR = 127,

        [System.Runtime.Serialization.EnumMember(Value = @"SDG")]
        SDG = 128,

        [System.Runtime.Serialization.EnumMember(Value = @"SEK")]
        SEK = 129,

        [System.Runtime.Serialization.EnumMember(Value = @"SGD")]
        SGD = 130,

        [System.Runtime.Serialization.EnumMember(Value = @"SHP")]
        SHP = 131,

        [System.Runtime.Serialization.EnumMember(Value = @"SLL")]
        SLL = 132,

        [System.Runtime.Serialization.EnumMember(Value = @"SOS")]
        SOS = 133,

        [System.Runtime.Serialization.EnumMember(Value = @"SRD")]
        SRD = 134,

        [System.Runtime.Serialization.EnumMember(Value = @"SSP")]
        SSP = 135,

        [System.Runtime.Serialization.EnumMember(Value = @"STN")]
        STN = 136,

        [System.Runtime.Serialization.EnumMember(Value = @"SVC")]
        SVC = 137,

        [System.Runtime.Serialization.EnumMember(Value = @"SYP")]
        SYP = 138,

        [System.Runtime.Serialization.EnumMember(Value = @"SZL")]
        SZL = 139,

        [System.Runtime.Serialization.EnumMember(Value = @"THB")]
        THB = 140,

        [System.Runtime.Serialization.EnumMember(Value = @"TJS")]
        TJS = 141,

        [System.Runtime.Serialization.EnumMember(Value = @"TMT")]
        TMT = 142,

        [System.Runtime.Serialization.EnumMember(Value = @"TND")]
        TND = 143,

        [System.Runtime.Serialization.EnumMember(Value = @"TOP")]
        TOP = 144,

        [System.Runtime.Serialization.EnumMember(Value = @"TRY")]
        TRY = 145,

        [System.Runtime.Serialization.EnumMember(Value = @"TTD")]
        TTD = 146,

        [System.Runtime.Serialization.EnumMember(Value = @"TWD")]
        TWD = 147,

        [System.Runtime.Serialization.EnumMember(Value = @"TZS")]
        TZS = 148,

        [System.Runtime.Serialization.EnumMember(Value = @"UAH")]
        UAH = 149,

        [System.Runtime.Serialization.EnumMember(Value = @"UGX")]
        UGX = 150,

        [System.Runtime.Serialization.EnumMember(Value = @"USD")]
        USD = 151,

        [System.Runtime.Serialization.EnumMember(Value = @"USN")]
        USN = 152,

        [System.Runtime.Serialization.EnumMember(Value = @"UYI")]
        UYI = 153,

        [System.Runtime.Serialization.EnumMember(Value = @"UYU")]
        UYU = 154,

        [System.Runtime.Serialization.EnumMember(Value = @"UYW")]
        UYW = 155,

        [System.Runtime.Serialization.EnumMember(Value = @"UZS")]
        UZS = 156,

        [System.Runtime.Serialization.EnumMember(Value = @"VES")]
        VES = 157,

        [System.Runtime.Serialization.EnumMember(Value = @"VND")]
        VND = 158,

        [System.Runtime.Serialization.EnumMember(Value = @"VUV")]
        VUV = 159,

        [System.Runtime.Serialization.EnumMember(Value = @"WST")]
        WST = 160,

        [System.Runtime.Serialization.EnumMember(Value = @"XAF")]
        XAF = 161,

        [System.Runtime.Serialization.EnumMember(Value = @"XAG")]
        XAG = 162,

        [System.Runtime.Serialization.EnumMember(Value = @"XAU")]
        XAU = 163,

        [System.Runtime.Serialization.EnumMember(Value = @"XBA")]
        XBA = 164,

        [System.Runtime.Serialization.EnumMember(Value = @"XBB")]
        XBB = 165,

        [System.Runtime.Serialization.EnumMember(Value = @"XBC")]
        XBC = 166,

        [System.Runtime.Serialization.EnumMember(Value = @"XBD")]
        XBD = 167,

        [System.Runtime.Serialization.EnumMember(Value = @"XCD")]
        XCD = 168,

        [System.Runtime.Serialization.EnumMember(Value = @"XDR")]
        XDR = 169,

        [System.Runtime.Serialization.EnumMember(Value = @"XOF")]
        XOF = 170,

        [System.Runtime.Serialization.EnumMember(Value = @"XPD")]
        XPD = 171,

        [System.Runtime.Serialization.EnumMember(Value = @"XPF")]
        XPF = 172,

        [System.Runtime.Serialization.EnumMember(Value = @"XPT")]
        XPT = 173,

        [System.Runtime.Serialization.EnumMember(Value = @"XSU")]
        XSU = 174,

        [System.Runtime.Serialization.EnumMember(Value = @"XUA")]
        XUA = 175,

        [System.Runtime.Serialization.EnumMember(Value = @"XXX")]
        XXX = 176,

        [System.Runtime.Serialization.EnumMember(Value = @"YER")]
        YER = 177,

        [System.Runtime.Serialization.EnumMember(Value = @"ZAR")]
        ZAR = 178,

        [System.Runtime.Serialization.EnumMember(Value = @"ZMW")]
        ZMW = 179,

        [System.Runtime.Serialization.EnumMember(Value = @"ZWL")]
        ZWL = 180,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EncryptionInfo
    {

        /// <summary>
        /// Klucz symetryczny zaszyfrowany algorytmem RSA (Padding: OAEP z SHA-256), zakodowany w formacie Base64.
        /// <br/>
        /// <br/>[Klucz publiczny RSA](/public-keys/publicKey.pem)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptedSymmetricKey", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string EncryptedSymmetricKey { get; set; }

        /// <summary>
        /// Wektor inicjalizujący (IV) używany do szyfrowania symetrycznego, zakodowany w formacie Base64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("initializationVector", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string InitializationVector { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EnrollCertificateRequest
    {

        /// <summary>
        /// Nazwa własna certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificateName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CertificateName { get; set; }

        /// <summary>
        /// Typ certyfikatu.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Authentication | Certyfikat używany do uwierzytelnienia w systemie. |
        /// <br/>| Offline | Certyfikat używany wyłącznie do potwierdzania autentyczności wystawcy i integralności faktury w trybie offline |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificateType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KsefCertificateType CertificateType { get; set; }

        /// <summary>
        /// Wniosek certyfikacyjny PKCS#10 (CSR) w formacie DER zakodowany w Base64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("csr", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] Csr { get; set; }

        /// <summary>
        /// Data rozpoczęcia ważności certyfikatu.
        /// <br/>Jeśli nie zostanie podana, certyfikat będzie ważny od momentu jego wystawienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ValidFrom { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EnrollCertificateResponse
    {

        /// <summary>
        /// Numer referencyjny operacji przetwarzania wniosku certyfikacyjnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ReferenceNumber { get; set; }

        /// <summary>
        /// Data złożenia wniosku certyfikacyjnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Timestamp { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityAuthorizationGrant
    {

        /// <summary>
        /// Identyfikator uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// Identyfikator osoby nadającej uprawnienie.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthorIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora osoby nadającej uprawnienie.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorIdentifierType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityAuthorizationsAuthorIdentifierType? AuthorIdentifierType { get; set; }

        /// <summary>
        /// Identyfikator podmiotu uprawnionego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedEntityIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthorizedEntityIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora podmiotu uprawnionego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedEntityIdentifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityAuthorizationsAuthorizedEntityIdentifierType AuthorizedEntityIdentifierType { get; set; }

        /// <summary>
        /// Identyfikator podmiotu uprawniającego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizingEntityIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthorizingEntityIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora podmiotu uprawniającego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizingEntityIdentifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityAuthorizationsAuthorizingEntityIdentifierType AuthorizingEntityIdentifierType { get; set; }

        /// <summary>
        /// Uprawnienie.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizationScope", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoicePermissionType AuthorizationScope { get; set; }

        /// <summary>
        /// Opis uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>
        /// Data rozpoczęcia obowiązywania uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntityAuthorizationPermissionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"SelfInvoicing")]
        SelfInvoicing = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"RRInvoicing")]
        RRInvoicing = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"TaxRepresentative")]
        TaxRepresentative = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityAuthorizationPermissionsGrantRequest
    {

        /// <summary>
        /// Identyfikator podmiotu.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EntityAuthorizationPermissionsSubjectIdentifier SubjectIdentifier { get; set; } = new EntityAuthorizationPermissionsSubjectIdentifier();

        /// <summary>
        /// Nadawane uprawnienie o charakterze upoważnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permission", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityAuthorizationPermissionType Permission { get; set; }

        /// <summary>
        /// Opis nadawanego uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityAuthorizationPermissionsQueryRequest
    {

        /// <summary>
        /// Identyfikator podmiotu uprawniającego.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizingIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EntityAuthorizationsAuthorizingEntityIdentifier AuthorizingIdentifier { get; set; }

        /// <summary>
        /// Identyfikator podmiotu uprawnionego.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EntityAuthorizationsAuthorizedEntityIdentifier AuthorizedIdentifier { get; set; }

        /// <summary>
        /// Typ zapytania.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Granted | Uprawnienia nadane innym podmiotom |
        /// <br/>| Received | Uprawnienia otrzymane od innych podmiotów |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("queryType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public QueryType QueryType { get; set; }

        /// <summary>
        /// Możliwe uprawnienia do filtrowania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissionTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<InvoicePermissionType> PermissionTypes { get; set; }

    }

    /// <summary>
    /// Identyfikator podmiotu.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityAuthorizationPermissionsSubjectIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityAuthorizationPermissionsSubjectIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntityAuthorizationPermissionsSubjectIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntityAuthorizationsAuthorIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Pesel")]
        Pesel = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 2,

    }

    /// <summary>
    /// Identyfikator podmiotu uprawnionego.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityAuthorizationsAuthorizedEntityIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityAuthorizationsAuthorizedEntityIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntityAuthorizationsAuthorizedEntityIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

    }

    /// <summary>
    /// Identyfikator podmiotu uprawniającego.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityAuthorizationsAuthorizingEntityIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityAuthorizationsAuthorizingEntityIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntityAuthorizationsAuthorizingEntityIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityPermission
    {

        /// <summary>
        /// Możliwe uprawnienia do nadania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityPermissionType Type { get; set; }

        /// <summary>
        /// Flaga pozwalająca na pośrednie przekazywanie danego uprawnienia
        /// </summary>
        [Newtonsoft.Json.JsonProperty("canDelegate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool CanDelegate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntityPermissionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceWrite")]
        InvoiceWrite = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceRead")]
        InvoiceRead = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityPermissionsGrantRequest
    {

        /// <summary>
        /// Identyfikator podmiotu.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EntityPermissionsSubjectIdentifier SubjectIdentifier { get; set; } = new EntityPermissionsSubjectIdentifier();

        /// <summary>
        /// Lista nadawanych uprawnień. Każda wartość może wystąpić tylko raz.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EntityPermission> Permissions { get; set; } = new System.Collections.ObjectModel.Collection<EntityPermission>();

        /// <summary>
        /// Opis nadawanych uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

    }

    /// <summary>
    /// Identyfikator podmiotu.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityPermissionsSubjectIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityPermissionsSubjectIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntityPermissionsSubjectIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

    }

    /// <summary>
    /// Identyfikator podmiotu podrzędnego.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityPermissionsSubordinateEntityIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityPermissionsSubordinateEntityIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntityPermissionsSubordinateEntityIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntityRole
    {

        /// <summary>
        /// Identyfikator podmiotu nadrzędnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parentEntityIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentEntityIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora podmiotu nadrzędnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parentEntityIdentifierType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityRolesParentEntityIdentifierType? ParentEntityIdentifierType { get; set; }

        /// <summary>
        /// Rola.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EntityRoleType Role { get; set; }

        /// <summary>
        /// Opis.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>
        /// Data rozpoczęcia obowiązywania roli.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntityRoleType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CourtBailiff")]
        CourtBailiff = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"EnforcementAuthority")]
        EnforcementAuthority = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"LocalGovernmentUnit")]
        LocalGovernmentUnit = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"LocalGovernmentSubUnit")]
        LocalGovernmentSubUnit = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"VatGroupUnit")]
        VatGroupUnit = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"VatGroupSubUnit")]
        VatGroupSubUnit = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EntityRolesParentEntityIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

    }

    /// <summary>
    /// Identyfikator zlożony z podmiotu polskiego i podmiotu unijnego.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| NipVatUe | Dwuczłonowy identyfikator składający się z numeru NIP i numeru VAT-UE: `{nip}-{vat_ue}` |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EuEntityAdministrationPermissionsContextIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EuEntityAdministrationPermissionsContextIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EuEntityAdministrationPermissionsContextIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NipVatUe")]
        NipVatUe = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EuEntityAdministrationPermissionsGrantRequest
    {

        /// <summary>
        /// Identyfikator podmiotu.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Fingerprint | Odcisk palca certyfikatu |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EuEntityAdministrationPermissionsSubjectIdentifier SubjectIdentifier { get; set; } = new EuEntityAdministrationPermissionsSubjectIdentifier();

        /// <summary>
        /// Identyfikator zlożony z podmiotu polskiego i podmiotu unijnego.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| NipVatUe | Dwuczłonowy identyfikator składający się z numeru NIP i numeru VAT-UE: `{nip}-{vat_ue}` |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EuEntityAdministrationPermissionsContextIdentifier ContextIdentifier { get; set; } = new EuEntityAdministrationPermissionsContextIdentifier();

        /// <summary>
        /// Opis nadawanych uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

    }

    /// <summary>
    /// Identyfikator podmiotu.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Fingerprint | Odcisk palca certyfikatu |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EuEntityAdministrationPermissionsSubjectIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EuEntityAdministrationPermissionsSubjectIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EuEntityAdministrationPermissionsSubjectIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EuEntityPermission
    {

        /// <summary>
        /// Identyfikator uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// Identyfikator uprawniającego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthorIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora uprawniającego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorIdentifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EuEntityPermissionsAuthorIdentifierType AuthorIdentifierType { get; set; }

        /// <summary>
        /// Identyfikator podmiotu unijnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vatUeIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string VatUeIdentifier { get; set; }

        /// <summary>
        /// Nazwa podmiotu unijnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("euEntityName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string EuEntityName { get; set; }

        /// <summary>
        /// Uprawniony odcisk palca certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedFingerprintIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthorizedFingerprintIdentifier { get; set; }

        /// <summary>
        /// Uprawnienie.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissionScope", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EuEntityPermissionsQueryPermissionType PermissionScope { get; set; }

        /// <summary>
        /// Opis uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>
        /// Data rozpoczęcia obowiązywania uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EuEntityPermissionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceWrite")]
        InvoiceWrite = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceRead")]
        InvoiceRead = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EuEntityPermissionsAuthorIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Pesel")]
        Pesel = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EuEntityPermissionsGrantRequest
    {

        /// <summary>
        /// Identyfikator podmiotu.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Fingerprint | Odcisk palca certyfikatu |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EuEntityPermissionsSubjectIdentifier SubjectIdentifier { get; set; } = new EuEntityPermissionsSubjectIdentifier();

        /// <summary>
        /// Lista nadawanych uprawnień. Każda wartość może wystąpić tylko raz.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EuEntityPermissionType> Permissions { get; set; } = new System.Collections.ObjectModel.Collection<EuEntityPermissionType>();

        /// <summary>
        /// Opis nadawanych uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EuEntityPermissionsQueryPermissionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"VatUeManage")]
        VatUeManage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceWrite")]
        InvoiceWrite = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceRead")]
        InvoiceRead = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Introspection")]
        Introspection = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EuEntityPermissionsQueryRequest
    {

        /// <summary>
        /// Identyfikator podmiotu unijnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vatUeIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VatUeIdentifier { get; set; }

        /// <summary>
        /// Uprawniony odcisk palca certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedFingerprintIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthorizedFingerprintIdentifier { get; set; }

        /// <summary>
        /// Możliwe uprawnienia do filtrowania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissionTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<EuEntityPermissionsQueryPermissionType> PermissionTypes { get; set; }

    }

    /// <summary>
    /// Identyfikator podmiotu.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Fingerprint | Odcisk palca certyfikatu |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EuEntityPermissionsSubjectIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EuEntityPermissionsSubjectIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EuEntityPermissionsSubjectIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExceptionDetails
    {

        [Newtonsoft.Json.JsonProperty("exceptionCode", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int ExceptionCode { get; set; }

        [Newtonsoft.Json.JsonProperty("exceptionDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExceptionDescription { get; set; }

        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Details { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExceptionInfo
    {

        [Newtonsoft.Json.JsonProperty("exceptionDetailList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ExceptionDetails> ExceptionDetailList { get; set; }

        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReferenceNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("serviceCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceCode { get; set; }

        [Newtonsoft.Json.JsonProperty("serviceCtx", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceCtx { get; set; }

        [Newtonsoft.Json.JsonProperty("serviceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceName { get; set; }

        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset Timestamp { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExceptionResponse
    {

        [Newtonsoft.Json.JsonProperty("exception", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExceptionInfo Exception { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExportInvoicesResponse
    {

        /// <summary>
        /// Numer referencyjny operacji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operationReferenceNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OperationReferenceNumber { get; set; }

    }

    /// <summary>
    /// Obsługiwane schematy:
    /// <br/>| SystemCode | SchemaVersion | Value |
    /// <br/>| --- | --- | --- |
    /// <br/>| FA (2) | 1-0E | FA |
    /// <br/>| FA (3) | 1-0E | FA |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FormCode
    {

        /// <summary>
        /// Kod systemowy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("systemCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SystemCode { get; set; }

        /// <summary>
        /// Wersja schematu
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schemaVersion", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SchemaVersion { get; set; }

        /// <summary>
        /// Wartość
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GenerateTokenRequest
    {

        /// <summary>
        /// Uprawnienia przypisane tokenowi.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<TokenPermissionType> Permissions { get; set; }

        /// <summary>
        /// Opis tokena.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GenerateTokenResponse
    {

        /// <summary>
        /// Numer referencyjny tokena KSeF. Za jego pomocą można sprawdzić jego status lub go unieważnić.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReferenceNumber { get; set; }

        /// <summary>
        /// Token KSeF.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Token { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum IndirectPermissionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceRead")]
        InvoiceRead = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceWrite")]
        InvoiceWrite = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IndirectPermissionsGrantRequest
    {

        /// <summary>
        /// Identyfikator osoby fizycznej.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// <br/>| Pesel | 11 cyfrowy numer PESEL |
        /// <br/>| Fingerprint | Odcisk palca certyfikatu |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IndirectPermissionsSubjectIdentifier SubjectIdentifier { get; set; } = new IndirectPermissionsSubjectIdentifier();

        /// <summary>
        /// Identyfikator podmiotu, w którego kontekście chcemy pośrednio nadać uprawnienia. W przypadku nadawania uprawnienia generalnego, pole to powinno mieć wartość null.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IndirectPermissionsTargetIdentifier TargetIdentifier { get; set; }

        /// <summary>
        /// Lista nadawanych uprawnień. Każda wartość może wystąpić tylko raz.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<IndirectPermissionType> Permissions { get; set; } = new System.Collections.ObjectModel.Collection<IndirectPermissionType>();

        /// <summary>
        /// Opis nadawanych uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

    }

    /// <summary>
    /// Identyfikator osoby fizycznej.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// <br/>| Pesel | 11 cyfrowy numer PESEL |
    /// <br/>| Fingerprint | Odcisk palca certyfikatu |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IndirectPermissionsSubjectIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IndirectPermissionsSubjectIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum IndirectPermissionsSubjectIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Pesel")]
        Pesel = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 2,

    }

    /// <summary>
    /// Identyfikator podmiotu, w którego kontekście chcemy pośrednio nadać uprawnienia. W przypadku nadawania uprawnienia generalnego, pole to powinno mieć wartość null.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IndirectPermissionsTargetIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IndirectPermissionsTargetIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum IndirectPermissionsTargetIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InitTokenAuthenticationRequest
    {

        /// <summary>
        /// Wygenerowany wcześniej challenge.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("challenge", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Challenge { get; set; }

        /// <summary>
        /// Indentyfikator kontekstu do którego następuje uwierzytelnienie.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ContextIdentifier ContextIdentifier { get; set; } = new ContextIdentifier();

        /// <summary>
        /// Zaszyfrowany token wraz z timestampem z challenge'a, w formacie `token|timestamp`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptedToken", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string EncryptedToken { get; set; }

        /// <summary>
        /// Reguła walidacji adresu IP klienta przy każdym użyciu tokena dostępu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ipAddressPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IpAddressPolicy IpAddressPolicy { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoiceMetadata
    {

        /// <summary>
        /// Numer KSeF faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ksefNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string KsefNumber { get; set; }

        /// <summary>
        /// Numer faktury nadany przez wystawcę.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string InvoiceNumber { get; set; }

        /// <summary>
        /// Data wystawienia faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("issueDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset IssueDate { get; set; }

        /// <summary>
        /// [Mock] Data przyjęcia faktury w systemie KSeF (do dalszego przetwarzania).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoicingDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset InvoicingDate { get; set; }

        /// <summary>
        /// Data nadania numeru KSeF.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("acquisitionDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset AcquisitionDate { get; set; }

        /// <summary>
        /// [Mock] Data trwałego zapisu faktury w repozytorium systemu KSeF.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permanentStorageDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset PermanentStorageDate { get; set; }

        /// <summary>
        /// Dane identyfikujące sprzedawcę.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seller", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public InvoiceMetadataSeller Seller { get; set; } = new InvoiceMetadataSeller();

        /// <summary>
        /// Dane identyfikujące nabywcę.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("buyer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public InvoiceMetadataBuyer Buyer { get; set; } = new InvoiceMetadataBuyer();

        /// <summary>
        /// Łączna kwota netto.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("netAmount", Required = Newtonsoft.Json.Required.Always)]
        public double NetAmount { get; set; }

        /// <summary>
        /// Łączna kwota brutto.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("grossAmount", Required = Newtonsoft.Json.Required.Always)]
        public double GrossAmount { get; set; }

        /// <summary>
        /// Łączna kwota VAT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vatAmount", Required = Newtonsoft.Json.Required.Always)]
        public double VatAmount { get; set; }

        /// <summary>
        /// Kod waluty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("currency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Currency { get; set; }

        /// <summary>
        /// Tryb fakturowania (online/offline).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoicingMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoicingMode? InvoicingMode { get; set; }

        /// <summary>
        /// Rodzaj faktury.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Vat | (FA) Podstawowa |
        /// <br/>| Zal | (FA) Zaliczkowa |
        /// <br/>| Kor | (FA) Korygująca |
        /// <br/>| Roz | (FA) Rozliczeniowa |
        /// <br/>| Upr | (FA) Uproszczona |
        /// <br/>| KorZal | (FA) Korygująca fakturę zaliczkową |
        /// <br/>| KorRoz | (FA) Korygująca fakturę rozliczeniową |
        /// <br/>| VatPef | [Mock] (PEF) Podstawowowa |
        /// <br/>| VatPefSp | [Mock] (PEF) Specjalizowana |
        /// <br/>| KorPef | [Mock] (PEF) Korygująca |
        /// <br/>| VatRr | [Mock] (RR) Podstawowa |
        /// <br/>| KorVatRr | [Mock] (RR) Korygująca |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoiceMetadataInvoiceType InvoiceType { get; set; }

        /// <summary>
        /// Struktura dokumentu faktury.
        /// <br/>
        /// <br/>Obsługiwane schematy:
        /// <br/>| SystemCode | SchemaVersion | Value |
        /// <br/>| --- | --- | --- |
        /// <br/>| FA (2) | 1-0E | FA |
        /// <br/>| FA (3) | 1-0E | FA |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public FormCode FormCode { get; set; } = new FormCode();

        /// <summary>
        /// Czy faktura została wystawiona w trybie samofakturowania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isSelfInvoicing", Required = Newtonsoft.Json.Required.Always)]
        public bool IsSelfInvoicing { get; set; }

        /// <summary>
        /// Czy faktura posiada załącznik.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasAttachment", Required = Newtonsoft.Json.Required.Always)]
        public bool HasAttachment { get; set; }

        /// <summary>
        /// [Mock] Skrót SHA256 faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileHash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FileHash { get; set; }

        /// <summary>
        /// [Mock] Skrót SHA256 korygowanej faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hashOfCorrectedInvoice", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HashOfCorrectedInvoice { get; set; }

        /// <summary>
        /// [Mock] Lista trzecich podmiotów.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("thirdSubjects", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InvoiceMetadataThirdSubject> ThirdSubjects { get; set; }

        /// <summary>
        /// [Mock] Podmiot upoważniony.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedSubject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InvoiceMetadataAuthorizedSubject AuthorizedSubject { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoiceMetadataAuthorizedSubject
    {

        /// <summary>
        /// Identyfikator podmiotu upoważnionego
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Identifier { get; set; }

        /// <summary>
        /// Nazwa podmiotu upoważnionego
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Rola podmiotu upoważnionego
        /// </summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Role { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoiceMetadataBuyer
    {

        /// <summary>
        /// Typ identyfikatora nabywcy.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| None | Brak identyfikatora nabywcy |
        /// <br/>| Other | Inny |
        /// <br/>| Nip | NIP |
        /// <br/>| VatUe | VAT UE |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BuyerIdentifierType IdentifierType { get; set; }

        /// <summary>
        /// Wartośc identyfikatora nabywcy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Identifier { get; set; }

        /// <summary>
        /// Nazwa nabywcy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| Vat | (FA) Podstawowa |
    /// <br/>| Zal | (FA) Zaliczkowa |
    /// <br/>| Kor | (FA) Korygująca |
    /// <br/>| Roz | (FA) Rozliczeniowa |
    /// <br/>| Upr | (FA) Uproszczona |
    /// <br/>| KorZal | (FA) Korygująca fakturę zaliczkową |
    /// <br/>| KorRoz | (FA) Korygująca fakturę rozliczeniową |
    /// <br/>| VatPef | [Mock] (PEF) Podstawowowa |
    /// <br/>| VatPefSp | [Mock] (PEF) Specjalizowana |
    /// <br/>| KorPef | [Mock] (PEF) Korygująca |
    /// <br/>| VatRr | [Mock] (RR) Podstawowa |
    /// <br/>| KorVatRr | [Mock] (RR) Korygująca |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InvoiceMetadataInvoiceType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Vat")]
        Vat = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Zal")]
        Zal = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Kor")]
        Kor = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Roz")]
        Roz = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Upr")]
        Upr = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"KorZal")]
        KorZal = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"KorRoz")]
        KorRoz = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"VatPef")]
        VatPef = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"VatPefSp")]
        VatPefSp = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"KorPef")]
        KorPef = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"VatRr")]
        VatRr = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"KorVatRr")]
        KorVatRr = 11,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoiceMetadataSeller
    {

        /// <summary>
        /// Identyfikator sprzedawcy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Identifier { get; set; }

        /// <summary>
        /// Nazwa sprzedawcy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoiceMetadataThirdSubject
    {

        /// <summary>
        /// Typ identyfikatora podmiotu trzeciego.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Nip | Nip |
        /// <br/>| InternalId | Identyfikator wewnętrzny |
        /// <br/>| VatUe | VAT UE |
        /// <br/>| Other | Inny identyfikator |
        /// <br/>| None | Brak identyfikatora podmiotu trzeciego |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identifierType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ThirdSubjectIdentifierType IdentifierType { get; set; }

        /// <summary>
        /// Wartość identyfikatora podmiotu trzeciego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Identifier { get; set; }

        /// <summary>
        /// Nazwa podmiotu trzeciego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Rola podmiotu trzeciego
        /// </summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Role { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoicePackagePart
    {

        /// <summary>
        /// Numer porządkowy pliku w ramach całego zbioru wynikowego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ordinalNumber", Required = Newtonsoft.Json.Required.Always)]
        public int OrdinalNumber { get; set; }

        /// <summary>
        /// Metoda HTTP, której należy użyć przy pobieraniu pliku.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Method { get; set; }

        /// <summary>
        /// Adres URL, pod który należy wysłać żądanie pobrania pliku.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Url { get; set; }

        /// <summary>
        /// Data wygaśnięcia linku do pobrania pliku.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expirationDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ExpirationDate { get; set; }

        /// <summary>
        /// Nagłówki, których należy użyć przy pobieraniu pliku.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("headers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, string> Headers { get; set; } = new System.Collections.Generic.Dictionary<string, string>();

        /// <summary>
        /// Nazwa pliku.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fileName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FileName { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InvoicePermissionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"SelfInvoicing")]
        SelfInvoicing = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"TaxRepresentative")]
        TaxRepresentative = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RRInvoicing")]
        RRInvoicing = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoiceQueryAmount
    {

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AmountType? Type { get; set; }

        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? From { get; set; }

        [Newtonsoft.Json.JsonProperty("to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? To { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoiceQueryBuyer
    {

        /// <summary>
        /// Typ identyfikatora nabywcy.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| None | Brak identyfikatora nabywcy |
        /// <br/>| Other | Inny |
        /// <br/>| Nip | NIP |
        /// <br/>| VatUe | VAT UE |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identifierType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BuyerIdentifierType? IdentifierType { get; set; }

        /// <summary>
        /// Wartość identyfikatora nabywcy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Identifier { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoiceQueryDateRange
    {

        /// <summary>
        /// Typ daty, według której ma być zastosowany zakres.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Issue | Data wystawienia faktury |
        /// <br/>| Invoicing | [Mock] Data przyjęcia faktury w systemie KSeF (do dalszego przetwarzania) |
        /// <br/>| PermanentStorage | [Mock] Data trwałego zapisu faktury w repozytorium systemu KSeF |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dateType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoiceQueryDateType DateType { get; set; }

        /// <summary>
        /// Data początkowa zakresu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset From { get; set; }

        /// <summary>
        /// Data końcowa zakresu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? To { get; set; }

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| Issue | Data wystawienia faktury |
    /// <br/>| Invoicing | [Mock] Data przyjęcia faktury w systemie KSeF (do dalszego przetwarzania) |
    /// <br/>| PermanentStorage | [Mock] Data trwałego zapisu faktury w repozytorium systemu KSeF |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InvoiceQueryDateType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Issue")]
        Issue = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Invoicing")]
        Invoicing = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"PermanentStorage")]
        PermanentStorage = 2,

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| FA | Faktura VAT |
    /// <br/>| PEF | Faktura PEF |
    /// <br/>| RR | Faktura RR |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InvoiceQueryFormType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"FA")]
        FA = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PEF")]
        PEF = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RR")]
        RR = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InvoiceQuerySchemaType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"FA1")]
        FA1 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"FA2")]
        FA2 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"FA3")]
        FA3 = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoiceQuerySeller
    {

        /// <summary>
        /// Identyfikator sprzedawcy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("identifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Identifier { get; set; }

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| Subject1 | Podmiot 1 |
    /// <br/>| Subject2 | Podmiot 2 |
    /// <br/>| Subject3 | Podmiot 3 |
    /// <br/>| SubjectAuthorized | Podmiot upoważniony |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InvoiceQuerySubjectType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Subject1")]
        Subject1 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Subject2")]
        Subject2 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Subject3")]
        Subject3 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"SubjectAuthorized")]
        SubjectAuthorized = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoicesExportFilters
    {

        /// <summary>
        /// Typ podmiotu, którego dotyczą kryteria filtrowania faktur.
        /// <br/>Określa kontekst, w jakim przeszukiwane są dane.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Subject1 | Podmiot 1 |
        /// <br/>| Subject2 | Podmiot 2 |
        /// <br/>| Subject3 | Podmiot 3 |
        /// <br/>| SubjectAuthorized | Podmiot upoważniony |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoiceQuerySubjectType SubjectType { get; set; }

        /// <summary>
        /// Typ i zakres dat, według którego mają być filtrowane faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dateRange", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public InvoiceQueryDateRange DateRange { get; set; } = new InvoiceQueryDateRange();

        /// <summary>
        /// Numer KSeF faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ksefNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KsefNumber { get; set; }

        /// <summary>
        /// Numer faktury nadany przez wystawcę.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InvoiceNumber { get; set; }

        /// <summary>
        /// Filtr kwotowy – brutto, netto lub VAT (z wartością).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InvoiceQueryAmount Amount { get; set; }

        /// <summary>
        /// Dane sprzedawcy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seller", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InvoiceQuerySeller Seller { get; set; }

        /// <summary>
        /// Dane nabywcy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("buyer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InvoiceQueryBuyer Buyer { get; set; }

        /// <summary>
        /// Kody walut.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("currencyCodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<CurrencyCode> CurrencyCodes { get; set; }

        /// <summary>
        /// Tryb wystawienia faktury: online lub offline.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoicingMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoicingMode? InvoicingMode { get; set; }

        /// <summary>
        /// Czy faktura została wystawiona w trybie samofakturowania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isSelfInvoicing", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsSelfInvoicing { get; set; }

        /// <summary>
        /// Struktura dokumentu.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| FA | Faktura VAT |
        /// <br/>| PEF | Faktura PEF |
        /// <br/>| RR | Faktura RR |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoiceQueryFormType? FormType { get; set; }

        /// <summary>
        /// Rodzaje faktur.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Vat | (FA) Podstawowa |
        /// <br/>| Zal | (FA) Zaliczkowa |
        /// <br/>| Kor | (FA) Korygująca |
        /// <br/>| Roz | (FA) Rozliczeniowa |
        /// <br/>| Upr | (FA) Uproszczona |
        /// <br/>| KorZal | (FA) Korygująca fakturę zaliczkową |
        /// <br/>| KorRoz | (FA) Korygująca fakturę rozliczeniową |
        /// <br/>| VatPef | [Mock] (PEF) Podstawowowa |
        /// <br/>| VatPefSp | [Mock] (PEF) Specjalizowana |
        /// <br/>| KorPef | [Mock] (PEF) Korygująca |
        /// <br/>| VatRr | [Mock] (RR) Podstawowa |
        /// <br/>| KorVatRr | [Mock] (RR) Korygująca |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<InvoiceMetadataInvoiceType> InvoiceTypes { get; set; }

        /// <summary>
        /// Czy faktura ma załącznik.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasAttachment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HasAttachment { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoicesExportPackage
    {

        /// <summary>
        /// Lista plików dostępnych do pobrania.
        /// <br/>Wypełniana tylko, gdy wynik zapytania jest gotowy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parts", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<InvoicePackagePart> Parts { get; set; } = new System.Collections.ObjectModel.Collection<InvoicePackagePart>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoicesExportRequest
    {

        /// <summary>
        /// Informacje wymagane do zaszyfrowania wyniku zapytania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryption", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EncryptionInfo Encryption { get; set; } = new EncryptionInfo();

        /// <summary>
        /// Zestaw filtrów do wyszukiwania faktur.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filters", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public InvoicesExportFilters Filters { get; set; } = new InvoicesExportFilters();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoicesExportStatusResponse
    {

        /// <summary>
        /// Informacje o aktualnym statusie przetwarzania zapytania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StatusInfo Status { get; set; } = new StatusInfo();

        /// <summary>
        /// Data przetworzenia zapytania
        /// </summary>
        [Newtonsoft.Json.JsonProperty("completedDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CompletedDate { get; set; }

        /// <summary>
        /// Informacje o paczce faktur.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("package", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InvoicesExportPackage Package { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InvoicesMetadataQueryRequest
    {

        /// <summary>
        /// Typ podmiotu, którego dotyczą kryteria filtrowania metadanych faktur.
        /// <br/>Określa kontekst, w jakim przeszukiwane są dane.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Subject1 | Podmiot 1 |
        /// <br/>| Subject2 | Podmiot 2 |
        /// <br/>| Subject3 | Podmiot 3 |
        /// <br/>| SubjectAuthorized | Podmiot upoważniony |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoiceQuerySubjectType SubjectType { get; set; }

        /// <summary>
        /// Typ i zakres dat, według którego mają być filtrowane faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dateRange", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public InvoiceQueryDateRange DateRange { get; set; } = new InvoiceQueryDateRange();

        /// <summary>
        /// Numer KSeF faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ksefNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KsefNumber { get; set; }

        /// <summary>
        /// Numer faktury nadany przez wystawcę.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InvoiceNumber { get; set; }

        /// <summary>
        /// Filtr kwotowy – brutto, netto lub VAT (z wartością).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InvoiceQueryAmount Amount { get; set; }

        /// <summary>
        /// Dane sprzedawcy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seller", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InvoiceQuerySeller Seller { get; set; }

        /// <summary>
        /// Dane nabywcy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("buyer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InvoiceQueryBuyer Buyer { get; set; }

        /// <summary>
        /// Kody walut.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("currencyCodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<CurrencyCode> CurrencyCodes { get; set; }

        /// <summary>
        /// Tryb wystawienia faktury: online lub offline.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoicingMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoicingMode? InvoicingMode { get; set; }

        /// <summary>
        /// Czy faktura została wystawiona w trybie samofakturowania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("isSelfInvoicing", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsSelfInvoicing { get; set; }

        [Newtonsoft.Json.JsonProperty("schemaType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.Obsolete]
        public InvoiceQuerySchemaType? SchemaType { get; set; }

        /// <summary>
        /// Typ dokumentu.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| FA | Faktura VAT |
        /// <br/>| PEF | Faktura PEF |
        /// <br/>| RR | Faktura RR |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoiceQueryFormType? FormType { get; set; }

        /// <summary>
        /// Rodzaje faktur.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Vat | (FA) Podstawowa |
        /// <br/>| Zal | (FA) Zaliczkowa |
        /// <br/>| Kor | (FA) Korygująca |
        /// <br/>| Roz | (FA) Rozliczeniowa |
        /// <br/>| Upr | (FA) Uproszczona |
        /// <br/>| KorZal | (FA) Korygująca fakturę zaliczkową |
        /// <br/>| KorRoz | (FA) Korygująca fakturę rozliczeniową |
        /// <br/>| VatPef | [Mock] (PEF) Podstawowowa |
        /// <br/>| VatPefSp | [Mock] (PEF) Specjalizowana |
        /// <br/>| KorPef | [Mock] (PEF) Korygująca |
        /// <br/>| VatRr | [Mock] (RR) Podstawowa |
        /// <br/>| KorVatRr | [Mock] (RR) Korygująca |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<InvoiceMetadataInvoiceType> InvoiceTypes { get; set; }

        /// <summary>
        /// Czy faktura ma załącznik.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasAttachment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HasAttachment { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InvoicingMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Online")]
        Online = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Offline")]
        Offline = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IpAddressPolicy
    {

        /// <summary>
        /// Określa reakcję systemu, gdy token dostępu zostanie użyty z adresu IP spoza zadeklarowanej listy dozwolonych adresów IP (allowedIps).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onClientIpChange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public IpChangePolicy? OnClientIpChange { get; set; }

        /// <summary>
        /// Lista dozwolonych adresów IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowedIps", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AllowedIps AllowedIps { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum IpChangePolicy
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Reject")]
        Reject = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Ignore")]
        Ignore = 1,

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| Authentication | Certyfikat używany do uwierzytelnienia w systemie. |
    /// <br/>| Offline | Certyfikat używany wyłącznie do potwierdzania autentyczności wystawcy i integralności faktury w trybie offline |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KsefCertificateType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Authentication")]
        Authentication = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Offline")]
        Offline = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OpenBatchSessionRequest
    {

        /// <summary>
        /// Schemat faktur wysyłanych w ramach sesji.
        /// <br/>
        /// <br/>Obsługiwane schematy:
        /// <br/>| SystemCode | SchemaVersion | Value |
        /// <br/>| --- | --- | --- |
        /// <br/>| FA (2) | 1-0E | FA |
        /// <br/>| FA (3) | 1-0E | FA |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public FormCode FormCode { get; set; } = new FormCode();

        /// <summary>
        /// Informacje o przesyłanej paczce faktur.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("batchFile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public BatchFileInfo BatchFile { get; set; } = new BatchFileInfo();

        /// <summary>
        /// Symetryczny klucz szyfrujący plik paczki, zaszyfrowany kluczem publicznym Ministerstwa Finansów.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryption", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EncryptionInfo Encryption { get; set; } = new EncryptionInfo();

        /// <summary>
        /// Określa, czy podatnik deklaruje tryb fakurowania "offline" dla dokumentów przesyłanych w sesji wsadowej.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("offlineMode", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool OfflineMode { get; set; } = false;

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OpenBatchSessionResponse
    {

        /// <summary>
        /// Numer referencyjny sesji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ReferenceNumber { get; set; }

        /// <summary>
        /// Dane wymagane do poprawnego przesłania poszczególnych części pliku paczki faktur.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partUploadRequests", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PartUploadRequest> PartUploadRequests { get; set; } = new System.Collections.ObjectModel.Collection<PartUploadRequest>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OpenOnlineSessionRequest
    {

        /// <summary>
        /// Schemat faktur wysyłanych w ramach sesji.
        /// <br/>
        /// <br/>Obsługiwane schematy:
        /// <br/>| SystemCode | SchemaVersion | Value |
        /// <br/>| --- | --- | --- |
        /// <br/>| FA (2) | 1-0E | FA |
        /// <br/>| FA (3) | 1-0E | FA |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("formCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public FormCode FormCode { get; set; } = new FormCode();

        /// <summary>
        /// Symetryczny klucz szyfrujący pliki XML, zaszyfrowany kluczem publicznym Ministerstwa Finansów.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryption", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EncryptionInfo Encryption { get; set; } = new EncryptionInfo();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OpenOnlineSessionResponse
    {

        /// <summary>
        /// Numer referencyjny sesji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ReferenceNumber { get; set; }

        /// <summary>
        /// Termin ważności sesji. Po jego upływie sesja zostanie automatycznie zamknięta.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validUntil", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ValidUntil { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PartUploadRequest
    {

        /// <summary>
        /// Numer sekwencyjny części pliku paczki.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ordinalNumber", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int OrdinalNumber { get; set; }

        /// <summary>
        /// Metoda HTTP, której należy użyć przy wysyłce części pliku paczki.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Method { get; set; }

        /// <summary>
        /// Adres pod który należy wysłać część pliku paczki.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri Url { get; set; }

        /// <summary>
        /// Nagłówki, których należy użyć przy wysyłce części pliku paczki.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PermissionState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Active")]
        Active = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Inactive")]
        Inactive = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PermissionsOperationResponse
    {

        /// <summary>
        /// Numer referencyjny asynchronicznej operacji nadawania lub odbierania uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operationReferenceNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OperationReferenceNumber { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PermissionsOperationStatusResponse
    {

        /// <summary>
        /// Informacje o aktualnym statusie.
        /// <br/>| Code | Description | Details |
        /// <br/>| --- | --- | --- |
        /// <br/>| 100 | Operacja przyjęta do realizacji | - |
        /// <br/>| 200 | Operacja zakończona sukcesem | - |
        /// <br/>| 400 | Operacja zakończona niepowodzeniem | - |
        /// <br/>| 410 | Podane identyfikatory są niezgodne lub pozostają w niewłaściwej relacji | - |
        /// <br/>| 420 | Użyte poświadczenia nie mają uprawnień do wykonania tej operacji | - |
        /// <br/>| 430 | Kontekst identyfikatora nie odpowiada wymaganej roli lub uprawnieniom | - |
        /// <br/>| 440 | Operacja niedozwolona dla wskazanych powiązań identyfikatorów | - |
        /// <br/>| 450 | Operacja niedozwolona dla wskazanego identyfikatora lub jego typu | - |
        /// <br/>| 500 | Nieznany błąd | - |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StatusInfo Status { get; set; } = new StatusInfo();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersonCreateRequest
    {

        [Newtonsoft.Json.JsonProperty("nip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nip { get; set; }

        [Newtonsoft.Json.JsonProperty("pesel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pesel { get; set; }

        [Newtonsoft.Json.JsonProperty("isBailiff", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsBailiff { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("createdDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedDate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersonPermission
    {

        /// <summary>
        /// Identyfikator uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// Identyfikator uprawnionego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthorizedIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora uprawnionego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedIdentifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersonPermissionsAuthorizedIdentifierType AuthorizedIdentifierType { get; set; }

        /// <summary>
        /// Identyfikator podmiotu docelowego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora podmiotu docelowego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetIdentifierType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersonPermissionsTargetIdentifierType? TargetIdentifierType { get; set; }

        /// <summary>
        /// Identyfikator uprawniającego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthorIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora uprawniającego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorIdentifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersonPermissionsAuthorIdentifierType AuthorIdentifierType { get; set; }

        /// <summary>
        /// Uprawnienie.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissionScope", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersonPermissionScope PermissionScope { get; set; }

        /// <summary>
        /// Opis uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>
        /// Stan uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissionState", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PermissionState PermissionState { get; set; }

        /// <summary>
        /// Data rozpoczęcia obowiązywania uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDate { get; set; }

        /// <summary>
        /// Informacja o możliwości dalszego nadawania uprawnienia w sposób pośredni.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("canDelegate", Required = Newtonsoft.Json.Required.Always)]
        public bool CanDelegate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PersonPermissionScope
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CredentialsManage")]
        CredentialsManage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CredentialsRead")]
        CredentialsRead = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceWrite")]
        InvoiceWrite = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceRead")]
        InvoiceRead = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Introspection")]
        Introspection = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"SubunitManage")]
        SubunitManage = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"EnforcementOperations")]
        EnforcementOperations = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"Owner")]
        Owner = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PersonPermissionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CredentialsManage")]
        CredentialsManage = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"CredentialsRead")]
        CredentialsRead = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceWrite")]
        InvoiceWrite = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceRead")]
        InvoiceRead = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Introspection")]
        Introspection = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"SubunitManage")]
        SubunitManage = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"EnforcementOperations")]
        EnforcementOperations = 6,

    }

    /// <summary>
    /// Identyfikator osoby lub podmiotu nadającego uprawnienie.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// <br/>| Pesel | 11 cyfrowy numer PESEL |
    /// <br/>| Fingerprint | Odcisk palca certyfikatu |
    /// <br/>| System | Identyfikator systemowy |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersonPermissionsAuthorIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersonPermissionsAuthorIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PersonPermissionsAuthorIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Pesel")]
        Pesel = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"System")]
        System = 3,

    }

    /// <summary>
    /// Identyfikator osoby lub podmiotu uprawnionego.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// <br/>| Pesel | 11 cyfrowy numer PESEL |
    /// <br/>| Fingerprint | Odcisk palca certyfikatu |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersonPermissionsAuthorizedIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersonPermissionsAuthorizedIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PersonPermissionsAuthorizedIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Pesel")]
        Pesel = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersonPermissionsGrantRequest
    {

        /// <summary>
        /// Identyfikator osoby fizycznej.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// <br/>| Pesel | 11 cyfrowy numer PESEL |
        /// <br/>| Fingerprint | Odcisk palca certyfikatu |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PersonPermissionsSubjectIdentifier SubjectIdentifier { get; set; } = new PersonPermissionsSubjectIdentifier();

        /// <summary>
        /// Lista nadawanych uprawnień. Każda wartość może wystąpić tylko raz.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PersonPermissionType> Permissions { get; set; } = new System.Collections.ObjectModel.Collection<PersonPermissionType>();

        /// <summary>
        /// Opis nadawanych uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersonPermissionsQueryRequest
    {

        /// <summary>
        /// Identyfikator osoby lub podmiotu nadającego uprawnienie.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// <br/>| Pesel | 11 cyfrowy numer PESEL |
        /// <br/>| Fingerprint | Odcisk palca certyfikatu |
        /// <br/>| System | Identyfikator systemowy |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PersonPermissionsAuthorIdentifier AuthorIdentifier { get; set; }

        /// <summary>
        /// Identyfikator osoby lub podmiotu uprawnionego.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// <br/>| Pesel | 11 cyfrowy numer PESEL |
        /// <br/>| Fingerprint | Odcisk palca certyfikatu |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PersonPermissionsAuthorizedIdentifier AuthorizedIdentifier { get; set; }

        /// <summary>
        /// Identyfikator podmiotu docelowego (dla uprawnień pośrednich).
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PersonPermissionsTargetIdentifier TargetIdentifier { get; set; }

        /// <summary>
        /// Możliwe uprawnienia do filtrowania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissionTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<PersonPermissionType> PermissionTypes { get; set; }

        /// <summary>
        /// Stan uprawnienia. 
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Active | Uprawnienia aktywne |
        /// <br/>| Inactive | Uprawnienia nieaktywne, nadane w sposób poœredni |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissionState", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PermissionState? PermissionState { get; set; }

        /// <summary>
        /// Typ zapytania.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| PermissionsInCurrentContext | Uprawnienia posiadane w aktualnym kontekście |
        /// <br/>| PermissionsGrantedInCurrentContext | Uprawnienia nadane w aktualnym kontekście |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("queryType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersonPermissionsQueryType QueryType { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PersonPermissionsQueryType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"PermissionsInCurrentContext")]
        PermissionsInCurrentContext = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PermissionsGrantedInCurrentContext")]
        PermissionsGrantedInCurrentContext = 1,

    }

    /// <summary>
    /// Identyfikator osoby fizycznej.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// <br/>| Pesel | 11 cyfrowy numer PESEL |
    /// <br/>| Fingerprint | Odcisk palca certyfikatu |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersonPermissionsSubjectIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersonPermissionsSubjectIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PersonPermissionsSubjectIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Pesel")]
        Pesel = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 2,

    }

    /// <summary>
    /// Identyfikator podmiotu docelowego (dla uprawnień pośrednich).
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersonPermissionsTargetIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersonPermissionsTargetIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PersonPermissionsTargetIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersonRemoveRequest
    {

        [Newtonsoft.Json.JsonProperty("nip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Nip { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PublicKeyCertificate
    {

        /// <summary>
        /// Certyfikat klucza publicznego w formacie DER zakodowany w Base64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Certificate { get; set; }

        /// <summary>
        /// Data początku obowiązywania certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validFrom", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ValidFrom { get; set; }

        /// <summary>
        /// Data końca obowiązywania certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validTo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ValidTo { get; set; }

        /// <summary>
        /// Operacje do których może być używany certyfikat.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| KsefTokenEncryption | Szyfrowanie tokenów KSeF przesyłanych w trakcie procesu uwierzytelniania. |
        /// <br/>| SymmetricKeyEncryption | Szyfrowanie klucza symetrycznego wykorzystywanego do szyfrowania przesyłanych faktur. |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usage", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PublicKeyCertificateUsage> Usage { get; set; } = new System.Collections.ObjectModel.Collection<PublicKeyCertificateUsage>();

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| KsefTokenEncryption | Szyfrowanie tokenów KSeF przesyłanych w trakcie procesu uwierzytelniania. |
    /// <br/>| SymmetricKeyEncryption | Szyfrowanie klucza symetrycznego wykorzystywanego do szyfrowania przesyłanych faktur. |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PublicKeyCertificateUsage
    {

        [System.Runtime.Serialization.EnumMember(Value = @"KsefTokenEncryption")]
        KsefTokenEncryption = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SymmetricKeyEncryption")]
        SymmetricKeyEncryption = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QueryCertificatesRequest
    {

        /// <summary>
        /// Numer seryjny certyfikatu. Wyszukiwanie odbywa się na zasadzie dokładnego dopasowania (exact match).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificateSerialNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CertificateSerialNumber { get; set; }

        /// <summary>
        /// Nazwa własna certyfikatu. Wyszukiwanie jest częściowe, czyli zwracane są certyfikaty, których nazwa zawiera podany ciąg znaków (contains).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Typ certyfikatu KSeF.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Authentication | Certyfikat używany do uwierzytelnienia w systemie. |
        /// <br/>| Offline | Certyfikat używany wyłącznie do potwierdzania autentyczności wystawcy i integralności faktury w trybie offline |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KsefCertificateType? Type { get; set; }

        /// <summary>
        /// Status certyfikatu.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Active | Certyfikat jest aktywny i może zostać użyty do uwierzytelnienia lub realizacji operacji w trybie offline (w zależności od typu certyfikatu). |
        /// <br/>| Blocked | Certyfikat został zablokowany i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline.            Status przejściowy do czasu zakończenia procesu unieważniania. |
        /// <br/>| Revoked | Certyfikat został unieważniony i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline. |
        /// <br/>| Expired | Certyfikat wygasł i nie może zostać użyty do uwierzytelnienia i realizacji operacji w trybie offline. |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CertificateListItemStatus? Status { get; set; }

        /// <summary>
        /// Filtruje certyfikaty, które wygasają po podanej dacie.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expiresAfter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ExpiresAfter { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QueryCertificatesResponse
    {

        /// <summary>
        /// Lista certyfikatów spełniających kryteria wyszukiwania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificates", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<CertificateListItem> Certificates { get; set; } = new System.Collections.ObjectModel.Collection<CertificateListItem>();

        /// <summary>
        /// Flaga informująca o dostępności kolejnej strony wyników.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Always)]
        public bool HasMore { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QueryEntityAuthorizationPermissionsResponse
    {

        /// <summary>
        /// Lista uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizationGrants", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EntityAuthorizationGrant> AuthorizationGrants { get; set; } = new System.Collections.ObjectModel.Collection<EntityAuthorizationGrant>();

        /// <summary>
        /// Flaga informująca o dostępności kolejnej strony wyników.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Always)]
        public bool HasMore { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QueryEntityRolesResponse
    {

        /// <summary>
        /// Lista ról.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roles", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EntityRole> Roles { get; set; } = new System.Collections.ObjectModel.Collection<EntityRole>();

        /// <summary>
        /// Flaga informująca o dostępności kolejnej strony wyników.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Always)]
        public bool HasMore { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QueryEuEntityPermissionsResponse
    {

        /// <summary>
        /// Lista uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<EuEntityPermission> Permissions { get; set; } = new System.Collections.ObjectModel.Collection<EuEntityPermission>();

        /// <summary>
        /// Flaga informująca o dostępności kolejnej strony wyników.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Always)]
        public bool HasMore { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QueryInvoicesMetadataReponse
    {

        /// <summary>
        /// Całkowita liczba pasujących rekordów w repozytorium.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.Always)]
        [System.Obsolete]
        public int TotalCount { get; set; }

        /// <summary>
        /// Flaga informująca o dostępności kolejnej strony wyników.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Always)]
        public bool HasMore { get; set; }

        /// <summary>
        /// Lista faktur spełniających kryteria.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoices", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<InvoiceMetadata> Invoices { get; set; } = new System.Collections.ObjectModel.Collection<InvoiceMetadata>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QueryPersonPermissionsResponse
    {

        /// <summary>
        /// Lista uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PersonPermission> Permissions { get; set; } = new System.Collections.ObjectModel.Collection<PersonPermission>();

        /// <summary>
        /// Flaga informująca o dostępności kolejnej strony wyników.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Always)]
        public bool HasMore { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QuerySubordinateEntityRolesResponse
    {

        /// <summary>
        /// Lista ról.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roles", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SubordinateEntityRole> Roles { get; set; } = new System.Collections.ObjectModel.Collection<SubordinateEntityRole>();

        /// <summary>
        /// Flaga informująca o dostępności kolejnej strony wyników.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Always)]
        public bool HasMore { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QuerySubunitPermissionsResponse
    {

        /// <summary>
        /// Lista uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SubunitPermission> Permissions { get; set; } = new System.Collections.ObjectModel.Collection<SubunitPermission>();

        /// <summary>
        /// Flaga informująca o dostępności kolejnej strony wyników.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasMore", Required = Newtonsoft.Json.Required.Always)]
        public bool HasMore { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QueryTokensResponse
    {

        /// <summary>
        /// Token służący do pobrania kolejnej strony wyników. Jeśli jest pusty, to nie ma kolejnych stron.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("continuationToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContinuationToken { get; set; }

        /// <summary>
        /// Lista tokenów uwierzytelniających.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tokens", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<AuthenticationToken> Tokens { get; set; } = new System.Collections.ObjectModel.Collection<AuthenticationToken>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum QueryType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Granted")]
        Granted = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Received")]
        Received = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RetrieveCertificatesListItem
    {

        /// <summary>
        /// Certyfikat w formacie DER zakodowany w Base64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public byte[] Certificate { get; set; }

        /// <summary>
        /// Nazwa własna certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificateName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CertificateName { get; set; }

        /// <summary>
        /// Numer seryjny certyfikatu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificateSerialNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CertificateSerialNumber { get; set; }

        /// <summary>
        /// Typ certyfikatu.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Authentication | Certyfikat używany do uwierzytelnienia w systemie. |
        /// <br/>| Offline | Certyfikat używany wyłącznie do potwierdzania autentyczności wystawcy i integralności faktury w trybie offline |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificateType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KsefCertificateType CertificateType { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RetrieveCertificatesRequest
    {

        /// <summary>
        /// Numery seryjne certyfikatów do pobrania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificateSerialNumbers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> CertificateSerialNumbers { get; set; } = new System.Collections.ObjectModel.Collection<string>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RetrieveCertificatesResponse
    {

        /// <summary>
        /// Pobrane certyfikaty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certificates", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RetrieveCertificatesListItem> Certificates { get; set; } = new System.Collections.ObjectModel.Collection<RetrieveCertificatesListItem>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RevokeCertificateRequest
    {

        /// <summary>
        /// Powód unieważnienia certyfikatu.
        /// <br/>| Wartość | Opis |
        /// <br/>| --- | --- |
        /// <br/>| Unspecified | Nieokreślony. |
        /// <br/>| Superseded | Certyfikat został zastąpiony przez inny. |
        /// <br/>| KeyCompromise | Klucz prywatny powiązany z certyfikatem został skompromitowany. |
        /// <br/>
        /// </summary>
        [Newtonsoft.Json.JsonProperty("revocationReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CertificateRevocationReason? RevocationReason { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SendInvoiceRequest
    {

        /// <summary>
        /// Skrót SHA256 oryginalnej faktury, zakodowany w formacie Base64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceHash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string InvoiceHash { get; set; }

        /// <summary>
        /// Rozmiar oryginalnej faktury w bajtach.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceSize", Required = Newtonsoft.Json.Required.Always)]
        public long InvoiceSize { get; set; }

        /// <summary>
        /// Skrót SHA256 zaszyfrowanej faktury, zakodowany w formacie Base64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptedInvoiceHash", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string EncryptedInvoiceHash { get; set; }

        /// <summary>
        /// Rozmiar zaszyfrowanej faktury w bajtach.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptedInvoiceSize", Required = Newtonsoft.Json.Required.Always)]
        public long EncryptedInvoiceSize { get; set; }

        /// <summary>
        /// Faktura zaszyfrowana algorytmem AES-256-CBC z dopełnianiem PKCS#7 (kluczem przekazanym przy otwarciu sesji), zakodowana w formacie Base64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("encryptedInvoiceContent", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string EncryptedInvoiceContent { get; set; }

        /// <summary>
        /// Określa, czy podatnik deklaruje tryb fakturowania "offline" dla przesyłanego dokumentu.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("offlineMode", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool OfflineMode { get; set; } = false;

        /// <summary>
        /// Skrót SHA256 korygowanej faktury, zakodowany w formacie Base64. Wymagany przy wysyłaniu korekty technicznej faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hashOfCorrectedInvoice", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HashOfCorrectedInvoice { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SendInvoiceResponse
    {

        /// <summary>
        /// Numer referencyjny faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ReferenceNumber { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SessionInvoiceStatusResponse
    {

        /// <summary>
        /// Numer sekwencyjny faktury w ramach sesji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ordinalNumber", Required = Newtonsoft.Json.Required.Always)]
        public int OrdinalNumber { get; set; }

        /// <summary>
        /// Numer faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InvoiceNumber { get; set; }

        /// <summary>
        /// Numer KSeF.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ksefNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KsefNumber { get; set; }

        /// <summary>
        /// Numer referencyjny faktury.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReferenceNumber { get; set; }

        /// <summary>
        /// Skrót SHA256 faktury, zakodowany w formacie Base64.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceHash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InvoiceHash { get; set; }

        /// <summary>
        /// Nazwa pliku faktury (zwracana dla faktur wysyłanych wsadowo).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceFileName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InvoiceFileName { get; set; }

        /// <summary>
        /// Data nadania numeru KSeF.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("acquisitionDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? AcquisitionDate { get; set; }

        /// <summary>
        /// Data przyjęcia faktury w systemie KSeF (do dalszego przetwarzania).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoicingDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset InvoicingDate { get; set; }

        /// <summary>
        /// Status faktury.
        /// <br/>
        /// <br/>| Code | Description | Details |
        /// <br/>| --- | --- | --- |
        /// <br/>| 100 | Faktura przyjęta do dalszego przetwarzania | - |
        /// <br/>| 150 | Trwa przetwarzanie | - |
        /// <br/>| 200 | Sukces | - |
        /// <br/>| 410 | Nieprawidłowy zakres uprawnień | - |
        /// <br/>| 415 | Brak możliwości wysyłania faktury z załącznikiem | - |
        /// <br/>| 430 | Błąd weryfikacji pliku faktury | - |
        /// <br/>| 435 | Błąd odszyfrowania pliku | - |
        /// <br/>| 440 | Duplikat faktury | - |
        /// <br/>| 450 | Błąd weryfikacji semantyki dokumentu faktury | - |
        /// <br/>| 500 | Nieznany błąd ({statusCode}) | - |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StatusInfo Status { get; set; } = new StatusInfo();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SessionInvoicesResponse
    {

        /// <summary>
        /// Token służący do pobrania kolejnej strony wyników. Jeśli jest pusty, to nie ma kolejnych stron.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("continuationToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContinuationToken { get; set; }

        /// <summary>
        /// Lista pobranych faktur.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoices", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SessionInvoiceStatusResponse> Invoices { get; set; } = new System.Collections.ObjectModel.Collection<SessionInvoiceStatusResponse>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SessionStatusResponse
    {

        /// <summary>
        /// Informacje o aktualnym statusie.
        /// <br/>            
        /// <br/>Sesja wsadowa:
        /// <br/>| Code | Description | Details |
        /// <br/>| --- | --- | --- |
        /// <br/>| 100 | Sesja wsadowa rozpoczęta | - |
        /// <br/>| 150 | Trwa przetwarzanie | - |
        /// <br/>| 200 | Sesja wsadowa przetworzona pomyślnie | - |
        /// <br/>| 405 | Błąd weryfikacji poprawności dostarczonych elementów paczki | - |
        /// <br/>| 415 | Błąd odszyfrowania dostarczonego klucza | - |
        /// <br/>| 430 | Błąd dekompresji pierwotnego archiwum | - |
        /// <br/>| 435 | Błąd odszyfrowania zaszyfrowanych części archiwum | - |
        /// <br/>| 440 | Sesja anulowana, przekroczono czas wysyłki | - |
        /// <br/>| 445 | Błąd weryfikacji, brak poprawnych faktur | - |
        /// <br/>| 500 | Nieznany błąd ({statusCode}) | - |
        /// <br/>
        /// <br/>Sesja interaktywna:
        /// <br/>| Code | Description | Details |
        /// <br/>| --- | --- | --- |
        /// <br/>| 100 | Sesja interaktywna otwarta | - |
        /// <br/>| 170 | Sesja interaktywna zamknięta | - |
        /// <br/>| 200 | Sesja interaktywna przetworzona pomyślnie | - |
        /// <br/>| 415 | Błąd odszyfrowania dostarczonego klucza | - |
        /// <br/>| 440 | Sesja anulowana, nie przesłano faktur | - |
        /// <br/>| 445 | Błąd weryfikacji, brak poprawnych faktur | - |
        /// <br/>| * | description missing | - |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StatusInfo Status { get; set; } = new StatusInfo();

        /// <summary>
        /// Termin ważności sesji. Po jego upływie sesja zostanie automatycznie zamknięta.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validUntil", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ValidUntil { get; set; }

        /// <summary>
        /// Informacja o UPO sesyjnym, zwracana gdy sesja została zamknięta i UPO zostało wygenerowane.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("upo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UpoResponse Upo { get; set; }

        /// <summary>
        /// Ilość przyjętych faktur w ramach sesji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invoiceCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? InvoiceCount { get; set; }

        /// <summary>
        /// Ilość faktur przeprocesowanych w ramach sesji z sukcesem .
        /// </summary>
        [Newtonsoft.Json.JsonProperty("successfulInvoiceCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SuccessfulInvoiceCount { get; set; }

        /// <summary>
        /// Ilość faktur przeprocesowanych w ramach sesji z błędem.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failedInvoiceCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FailedInvoiceCount { get; set; }

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| Online | Wysyłka interaktywna (pojedyncze faktury). |
    /// <br/>| Batch | Wysyłka wsadowa (paczka faktur). |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SessionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Online")]
        Online = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Batch")]
        Batch = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SessionsQueryResponse
    {

        /// <summary>
        /// Token służący do pobrania kolejnej strony wyników. Jeśli jest pusty, to nie ma kolejnych stron.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("continuationToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContinuationToken { get; set; }

        /// <summary>
        /// Lista sesji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sessions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SessionsQueryResponseItem> Sessions { get; set; } = new System.Collections.ObjectModel.Collection<SessionsQueryResponseItem>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SessionsQueryResponseItem
    {

        /// <summary>
        /// Numer referencyjny sesji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ReferenceNumber { get; set; }

        /// <summary>
        /// Status sesji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public StatusInfo Status { get; set; } = new StatusInfo();

        /// <summary>
        /// Data utowrzenia sesji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dateCreated", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset DateCreated { get; set; }

        /// <summary>
        /// Data ostatniej aktywności w ramach sesji.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dateUpdated", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset DateUpdated { get; set; }

        /// <summary>
        /// Termin ważności sesji. Po jego upływie sesja interaktywna zostanie automatycznie zamknięta.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validUntil", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ValidUntil { get; set; }

        /// <summary>
        /// Łączna liczba faktur (uwzględnia również te w trakcie przetwarzania).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("totalInvoiceCount", Required = Newtonsoft.Json.Required.Always)]
        public int TotalInvoiceCount { get; set; }

        /// <summary>
        /// Liczba poprawnie przetworzonych faktur.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("successfulInvoiceCount", Required = Newtonsoft.Json.Required.Always)]
        public int SuccessfulInvoiceCount { get; set; }

        /// <summary>
        /// Liczba błędnie przetworzonych faktur.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failedInvoiceCount", Required = Newtonsoft.Json.Required.Always)]
        public int FailedInvoiceCount { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StatusInfo
    {

        /// <summary>
        /// Kod statusu
        /// </summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        public int Code { get; set; }

        /// <summary>
        /// Opis statusu
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public string Description { get; set; }

        /// <summary>
        /// Dodatkowe szczegóły statusu
        /// </summary>
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Details { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubjectCreateRequest
    {

        [Newtonsoft.Json.JsonProperty("subjectNip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubjectNip { get; set; }

        [Newtonsoft.Json.JsonProperty("subjectType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubjectType SubjectType { get; set; }

        [Newtonsoft.Json.JsonProperty("subunits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Subunit> Subunits { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("createdDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedDate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubjectIdentifier
    {

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubjectIdentifierType Type { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SubjectIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Pesel")]
        Pesel = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Token")]
        Token = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubjectRemoveRequest
    {

        [Newtonsoft.Json.JsonProperty("subjectNip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubjectNip { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SubjectType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EnforcementAuthority")]
        EnforcementAuthority = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"VatGroup")]
        VatGroup = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"JST")]
        JST = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubordinateEntityRole
    {

        /// <summary>
        /// Identyfikator podmiotu podrzędnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subordinateEntityIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SubordinateEntityIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora podmiotu podrzędnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subordinateEntityIdentifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubordinateRoleSubordinateEntityIdentifierType SubordinateEntityIdentifierType { get; set; }

        /// <summary>
        /// Powiązanie.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubordinateEntityRoleType Role { get; set; }

        /// <summary>
        /// Opis.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>
        /// Data rozpoczęcia obowiązywania powiązania.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SubordinateEntityRoleType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"LocalGovernmentSubUnit")]
        LocalGovernmentSubUnit = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"VatGroupSubUnit")]
        VatGroupSubUnit = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubordinateEntityRolesQueryRequest
    {

        /// <summary>
        /// Identyfikator podmiotu podrzędnego.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subordinateEntityIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EntityPermissionsSubordinateEntityIdentifier SubordinateEntityIdentifier { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SubordinateRoleSubordinateEntityIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Subunit
    {

        [Newtonsoft.Json.JsonProperty("subjectNip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubjectNip { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubunitPermission
    {

        /// <summary>
        /// Identyfikator uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// Identyfikator uprawnionego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthorizedIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora uprawnionego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorizedIdentifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubunitPermissionsSubjectIdentifierType AuthorizedIdentifierType { get; set; }

        /// <summary>
        /// Identyfikator podmiotu podrzędnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subunitIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SubunitIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora podmiotu podrzędnego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subunitIdentifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubunitPermissionsSubunitIdentifierType SubunitIdentifierType { get; set; }

        /// <summary>
        /// Identyfikator uprawniającego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthorIdentifier { get; set; }

        /// <summary>
        /// Typ identyfikatora uprawniającego.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("authorIdentifierType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubunitPermissionsAuthorIdentifierType AuthorIdentifierType { get; set; }

        /// <summary>
        /// Uprawnienie.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("permissionScope", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubunitPermissionScope PermissionScope { get; set; }

        /// <summary>
        /// Opis uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>
        /// Data rozpoczęcia obowiązywania uprawnienia.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SubunitPermissionScope
    {

        [System.Runtime.Serialization.EnumMember(Value = @"CredentialsManage")]
        CredentialsManage = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SubunitPermissionsAuthorIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Pesel")]
        Pesel = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 2,

    }

    /// <summary>
    /// Identyfikator podmiotu podrzędnego.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// <br/>| InternalId | Dwuczłonowy identyfikator składający się z numeru NIP i 5 cyfr: `{nip}-{5_cyfr}` |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubunitPermissionsContextIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubunitPermissionsContextIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SubunitPermissionsContextIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"InternalId")]
        InternalId = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubunitPermissionsGrantRequest
    {

        /// <summary>
        /// Identyfikator podmiotu lub osoby fizycznej.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// <br/>| Pesel | 11 cyfrowy numer PESEL |
        /// <br/>| Fingerprint | Odcisk palca certyfikatu |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subjectIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SubunitPermissionsSubjectIdentifier SubjectIdentifier { get; set; } = new SubunitPermissionsSubjectIdentifier();

        /// <summary>
        /// Identyfikator podmiotu podrzędnego.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// <br/>| InternalId | Dwuczłonowy identyfikator składający się z numeru NIP i 5 cyfr: `{nip}-{5_cyfr}` |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextIdentifier", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SubunitPermissionsContextIdentifier ContextIdentifier { get; set; } = new SubunitPermissionsContextIdentifier();

        /// <summary>
        /// Opis nadawanych uprawnień.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubunitPermissionsQueryRequest
    {

        /// <summary>
        /// Identyfikator jednostki lub podmiotu podrzędnego.
        /// <br/>| Type | Value |
        /// <br/>| --- | --- |
        /// <br/>| InternalId | Dwuczłonowy identyfikator składający się z numeru NIP i 5 cyfr: `{nip}-{5_cyfr}` |
        /// <br/>| Nip | 10 cyfrowy numer NIP |
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subunitIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubunitPermissionsSubunitIdentifier SubunitIdentifier { get; set; }

    }

    /// <summary>
    /// Identyfikator podmiotu lub osoby fizycznej.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// <br/>| Pesel | 11 cyfrowy numer PESEL |
    /// <br/>| Fingerprint | Odcisk palca certyfikatu |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubunitPermissionsSubjectIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubunitPermissionsSubjectIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SubunitPermissionsSubjectIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Pesel")]
        Pesel = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 2,

    }

    /// <summary>
    /// Identyfikator jednostki lub podmiotu podrzędnego.
    /// <br/>| Type | Value |
    /// <br/>| --- | --- |
    /// <br/>| InternalId | Dwuczłonowy identyfikator składający się z numeru NIP i 5 cyfr: `{nip}-{5_cyfr}` |
    /// <br/>| Nip | 10 cyfrowy numer NIP |
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubunitPermissionsSubunitIdentifier
    {

        /// <summary>
        /// Typ identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SubunitPermissionsSubunitIdentifierType Type { get; set; }

        /// <summary>
        /// Wartość identyfikatora.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SubunitPermissionsSubunitIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"InternalId")]
        InternalId = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TestDataAuthorizedIdentifier
    {

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TestDataAuthorizedIdentifierType Type { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TestDataAuthorizedIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Pesel")]
        Pesel = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Fingerprint")]
        Fingerprint = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TestDataContextIdentifier
    {

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TestDataContextIdentifierType Type { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TestDataContextIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TestDataPermission
    {

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("permissionType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TestDataPermissionType PermissionType { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TestDataPermissionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceRead")]
        InvoiceRead = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceWrite")]
        InvoiceWrite = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Introspection")]
        Introspection = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CredentialsRead")]
        CredentialsRead = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"CredentialsManage")]
        CredentialsManage = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"EnforcementOperations")]
        EnforcementOperations = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"SubunitManage")]
        SubunitManage = 6,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TestDataPermissionsGrantRequest
    {

        [Newtonsoft.Json.JsonProperty("contextIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TestDataContextIdentifier ContextIdentifier { get; set; }

        [Newtonsoft.Json.JsonProperty("authorizedIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TestDataAuthorizedIdentifier AuthorizedIdentifier { get; set; }

        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TestDataPermission> Permissions { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TestDataPermissionsRevokeRequest
    {

        [Newtonsoft.Json.JsonProperty("contextIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TestDataContextIdentifier ContextIdentifier { get; set; }

        [Newtonsoft.Json.JsonProperty("authorizedIdentifier", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TestDataAuthorizedIdentifier AuthorizedIdentifier { get; set; }

    }

    /// <summary>
    /// | Wartość | Opis |
    /// <br/>| --- | --- |
    /// <br/>| Nip | Nip |
    /// <br/>| InternalId | Identyfikator wewnętrzny |
    /// <br/>| VatUe | VAT UE |
    /// <br/>| Other | Inny identyfikator |
    /// <br/>| None | Brak identyfikatora podmiotu trzeciego |
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ThirdSubjectIdentifierType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Nip")]
        Nip = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"InternalId")]
        InternalId = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"VatUe")]
        VatUe = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TokenInfo
    {

        /// <summary>
        /// Token w formacie JWT.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Token { get; set; }

        /// <summary>
        /// Data ważności tokena.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("validUntil", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ValidUntil { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TokenPermissionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceRead")]
        InvoiceRead = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"InvoiceWrite")]
        InvoiceWrite = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"CredentialsRead")]
        CredentialsRead = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CredentialsManage")]
        CredentialsManage = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpoPageResponse
    {

        /// <summary>
        /// Numer referencyjny strony UPO.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("referenceNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ReferenceNumber { get; set; }

        /// <summary>
        /// Adres do pobrania strony UPO.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("downloadUrl", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri DownloadUrl { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpoResponse
    {

        /// <summary>
        /// Lista stron UPO.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pages", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<UpoPageResponse> Pages { get; set; } = new System.Collections.ObjectModel.Collection<UpoPageResponse>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    internal class DateFormatConverter : Newtonsoft.Json.Converters.IsoDateTimeConverter
    {
        public DateFormatConverter()
        {
            DateTimeFormat = "yyyy-MM-dd";
        }
    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.0.0 (NJsonSchema v11.5.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765